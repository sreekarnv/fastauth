{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>Multiple Providers Email/password, Google OAuth, and GitHub OAuth out of the box.</p> <p>Pluggable Adapters SQLAlchemy (SQLite, PostgreSQL, MySQL) or bring your own adapter.</p> <p>JWT &amp; Sessions</p> <p>Stateless tokens or server-side database sessions -&gt; your choice.</p> <p>Cookie Delivery</p> <p>HttpOnly, Secure, SameSite-strict cookies with zero extra config.</p> <p>Email Flows</p> <p>Verification and password reset with pluggable transports (SMTP, webhook, console).</p> <p>RBAC</p> <p>Roles and fine-grained permissions enforced on any route via <code>Depends</code>.</p> <p>Event Hooks</p> <p>Intercept sign-in, sign-up, and mutate JWT payloads via a single interface.</p> <p>RS256 / JWKS</p> <p>Rotate signing keys and expose a JWKS endpoint for microservice architectures.</p>"},{"location":"#fastauth","title":"FastAuth","text":"<p> NextAuth-inspired pluggable authentication for FastAPI. </p> <p> Complete auth system - credentials, OAuth, email verification, password reset, RBAC, and JWT in minutes, without locking you into any database or ORM. </p> <p>Get Started GitHub</p>"},{"location":"#install","title":"Install","text":"pipuvpoetry <pre><code>pip install \"sreekarnv-fastauth[standard]\"\n</code></pre> <pre><code>uv add \"sreekarnv-fastauth[standard]\"\n</code></pre> <pre><code>poetry add \"sreekarnv-fastauth[standard]\"\n</code></pre> <p>The <code>standard</code> extra includes FastAPI, JWT (joserfc + cryptography), SQLAlchemy, and Argon2. See Installation for the full extras table.</p>"},{"location":"#taste-of-the-api","title":"Taste of the API","text":"<pre><code>from contextlib import asynccontextmanager\nfrom fastapi import Depends, FastAPI\nfrom fastauth import FastAuth, FastAuthConfig\nfrom fastauth.adapters.sqlalchemy import SQLAlchemyAdapter\nfrom fastauth.api.deps import require_auth, require_role\nfrom fastauth.providers.credentials import CredentialsProvider\n\nadapter = SQLAlchemyAdapter(engine_url=\"sqlite+aiosqlite:///./auth.db\")\n\nauth = FastAuth(FastAuthConfig(\n    secret=\"change-me-in-production\",   # fastauth generate-secret\n    providers=[CredentialsProvider()],\n    adapter=adapter.user,\n    token_adapter=adapter.token,\n))\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    await adapter.create_tables()\n    yield\n\napp = FastAPI(lifespan=lifespan)\nauth.mount(app)  # registers /auth/signup, /auth/signin, /auth/signout, \u2026\n\n@app.get(\"/dashboard\")\nasync def dashboard(user=Depends(require_auth)):\n    return {\"hello\": user[\"email\"]}\n\n@app.get(\"/admin\")\nasync def admin(user=Depends(require_role(\"admin\"))):\n    return {\"message\": \"welcome, admin\"}\n</code></pre> <p><code>auth.mount(app)</code> registers all auth endpoints automatically. Your routes just use <code>Depends(require_auth)</code>.</p>"},{"location":"#next-steps","title":"Next steps","text":"<ul> <li>Installation \u2014 extras, drivers, optional deps</li> <li>Quick Start \u2014 a minimal working app in 15 lines</li> <li>Configuration \u2014 every config field explained</li> <li>How it Works \u2014 architecture overview with diagrams</li> </ul>"},{"location":"cli/","title":"CLI Reference","text":"<p>FastAuth includes a CLI for scaffolding, secret generation, and dependency checking.</p>"},{"location":"cli/#install","title":"Install","text":"<p>The CLI is available when the <code>cli</code> extra is installed:</p> <pre><code>pip install \"sreekarnv-fastauth[cli]\"\n# or\npip install \"sreekarnv-fastauth[all]\"\n</code></pre>"},{"location":"cli/#commands","title":"Commands","text":""},{"location":"cli/#fastauth-version","title":"<code>fastauth version</code>","text":"<p>Print the installed FastAuth version.</p> <pre><code>fastauth version\n# FastAuth v0.3.0\n</code></pre>"},{"location":"cli/#fastauth-generate-secret","title":"<code>fastauth generate-secret</code>","text":"<p>Generate a cryptographically secure random secret for use as <code>FastAuthConfig.secret</code>.</p> <pre><code>fastauth generate-secret\n# \u2192 64-byte URL-safe base64 string\n\nfastauth generate-secret --length 32\n# \u2192 shorter secret (bytes, not characters)\n</code></pre> <p>Options:</p> Flag Default Description <code>--length</code>, <code>-l</code> <code>64</code> Byte length of the generated token <p>Copy the output directly into your environment:</p> <pre><code>export FASTAUTH_SECRET=$(fastauth generate-secret)\n</code></pre>"},{"location":"cli/#fastauth-check","title":"<code>fastauth check</code>","text":"<p>Display the installation status of all optional FastAuth dependencies.</p> <pre><code>fastauth check\n</code></pre> <p>Example output:</p> <pre><code>FastAuth v0.3.0 \u2014 Dependency Status\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Extra      \u2503 Package        \u2503 Status                                   \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 fastapi    \u2502 fastapi        \u2502 \u2713  installed                             \u2502\n\u2502 jwt        \u2502 joserfc        \u2502 \u2713  installed                             \u2502\n\u2502 jwt        \u2502 cryptography   \u2502 \u2713  installed                             \u2502\n\u2502 oauth      \u2502 httpx          \u2502 \u2717  missing   pip install ...[oauth]      \u2502\n\u2502 sqlalchemy \u2502 sqlalchemy     \u2502 \u2713  installed                             \u2502\n\u2502 redis      \u2502 redis          \u2502 \u2717  missing   pip install ...[redis]      \u2502\n\u2502 argon2     \u2502 argon2-cffi    \u2502 \u2713  installed                             \u2502\n\u2502 email      \u2502 aiosmtplib     \u2502 \u2717  missing   pip install ...[email]      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"cli/#fastauth-providers","title":"<code>fastauth providers</code>","text":"<p>List all available authentication providers and their status.</p> <pre><code>fastauth providers\n</code></pre>"},{"location":"cli/#fastauth-init-output_dir","title":"<code>fastauth init [OUTPUT_DIR]</code>","text":"<p>Scaffold a new FastAuth project with template files.</p> <pre><code>fastauth init              # scaffold in current directory\nfastauth init ./myapp      # scaffold in ./myapp/\nfastauth init . --force    # overwrite existing files\n</code></pre> <p>Creates two files:</p> <p><code>fastauth_config.py</code> \u2014 pre-filled configuration with a placeholder secret:</p> <pre><code>from fastauth import FastAuth, FastAuthConfig\nfrom fastauth.providers.credentials import CredentialsProvider\nfrom fastauth.adapters.sqlalchemy import SQLAlchemyAdapter\n\nSECRET = \"change-me-in-production\"\n\nadapter = SQLAlchemyAdapter(engine_url=\"sqlite+aiosqlite:///./auth.db\")\n\nconfig = FastAuthConfig(\n    secret=SECRET,\n    providers=[CredentialsProvider()],\n    adapter=adapter.user,\n    token_adapter=adapter.token,\n    base_url=\"http://localhost:8000\",\n)\n\nauth = FastAuth(config)\n</code></pre> <p><code>main.py</code> \u2014 a minimal FastAPI app that mounts FastAuth:</p> <pre><code>from contextlib import asynccontextmanager\nfrom fastapi import FastAPI\nfrom fastauth_config import adapter, auth\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    await adapter.create_tables()\n    yield\n\napp = FastAPI(lifespan=lifespan)\nauth.mount(app)\n</code></pre> <p>After <code>init</code>, the CLI prints next steps:</p> <pre><code>Next steps:\n  1. Replace SECRET in fastauth_config.py with:\n       fastauth generate-secret\n  2. Run your app:\n       uvicorn main:app --reload\n</code></pre> <p>Options:</p> Flag Description <code>--force</code>, <code>-f</code> Overwrite files that already exist"},{"location":"adapters/custom/","title":"Custom Adapter","text":"<p>You can use any database or ORM by implementing the <code>UserAdapter</code> protocol. FastAuth uses structural subtyping (duck typing) \u2014 your class just needs the right methods.</p>"},{"location":"adapters/custom/#implementing-useradapter","title":"Implementing UserAdapter","text":"<pre><code>from fastauth.types import UserData\n\nclass MyUserAdapter:\n    \"\"\"Example adapter backed by a hypothetical async ORM.\"\"\"\n\n    async def create_user(\n        self, email: str, hashed_password: str | None = None, **kwargs\n    ) -&gt; UserData:\n        record = await db.users.insert(email=email, hashed_password=hashed_password)\n        return {\"id\": str(record.id), \"email\": record.email, \"is_active\": True}\n\n    async def get_user_by_id(self, user_id: str) -&gt; UserData | None:\n        record = await db.users.find_one(id=user_id)\n        return _to_user_data(record) if record else None\n\n    async def get_user_by_email(self, email: str) -&gt; UserData | None:\n        record = await db.users.find_one(email=email)\n        return _to_user_data(record) if record else None\n\n    async def update_user(self, user_id: str, **kwargs) -&gt; UserData:\n        record = await db.users.update(id=user_id, **kwargs)\n        return _to_user_data(record)\n\n    async def delete_user(self, user_id: str, soft: bool = True) -&gt; None:\n        if soft:\n            await db.users.update(id=user_id, is_active=False)\n        else:\n            await db.users.delete(id=user_id)\n\n    async def get_hashed_password(self, user_id: str) -&gt; str | None:\n        record = await db.users.find_one(id=user_id)\n        return record.hashed_password if record else None\n\n    async def set_hashed_password(self, user_id: str, hashed_password: str) -&gt; None:\n        await db.users.update(id=user_id, hashed_password=hashed_password)\n</code></pre>"},{"location":"adapters/custom/#userdata-shape","title":"UserData shape","text":"<p>FastAuth expects a <code>UserData</code> <code>TypedDict</code> from every adapter method. At minimum:</p> <pre><code>{\n    \"id\": \"unique-user-id\",       # str, required\n    \"email\": \"alice@example.com\", # str, required\n    \"is_active\": True,            # bool, required\n    # Any extra fields are passed through to hooks and JWT claims\n}\n</code></pre>"},{"location":"adapters/custom/#the-full-useradapter-protocol","title":"The full UserAdapter protocol","text":"<pre><code>class UserAdapter(Protocol):\n    async def create_user(self, email, hashed_password=None, **kwargs) -&gt; UserData: ...\n    async def get_user_by_id(self, user_id) -&gt; UserData | None: ...\n    async def get_user_by_email(self, email) -&gt; UserData | None: ...\n    async def update_user(self, user_id, **kwargs) -&gt; UserData: ...\n    async def delete_user(self, user_id, soft=True) -&gt; None: ...\n    async def get_hashed_password(self, user_id) -&gt; str | None: ...\n    async def set_hashed_password(self, user_id, hashed_password) -&gt; None: ...\n</code></pre>"},{"location":"adapters/custom/#other-protocols","title":"Other protocols","text":"<p>If you need token storage, OAuth account linking, or RBAC, implement the corresponding protocols:</p> Protocol Required for <code>TokenAdapter</code> Email verification, password reset <code>OAuthAccountAdapter</code> OAuth providers <code>SessionAdapter</code> <code>session_strategy=\"database\"</code> <code>RoleAdapter</code> RBAC <p>All protocols are defined in <code>fastauth.core.protocols</code>. See the Protocols Reference for the full signatures.</p>"},{"location":"adapters/memory/","title":"Memory Adapter","text":"<p>An in-memory user adapter for testing and development. No database, no setup \u2014 data lives in a Python dict and is lost when the process exits.</p>"},{"location":"adapters/memory/#usage","title":"Usage","text":"<pre><code>from fastauth.adapters.memory import MemoryUserAdapter\n\nconfig = FastAuthConfig(\n    adapter=MemoryUserAdapter(),\n    ...\n)\n</code></pre>"},{"location":"adapters/memory/#when-to-use-it","title":"When to use it","text":"<ul> <li>Unit tests \u2014 fast, zero-dependency fixtures</li> <li>Prototyping \u2014 spin up a working auth server without any database</li> <li>CI pipelines \u2014 no external services needed</li> </ul>"},{"location":"adapters/memory/#limitations","title":"Limitations","text":"<ul> <li>Data is not persisted between restarts</li> <li>No <code>token_adapter</code>, <code>oauth_adapter</code>, or <code>role_adapter</code> implementations   (use the <code>SQLAlchemyAdapter</code> when you need those)</li> <li>Not suitable for multi-process deployments (each process has its own memory)</li> </ul>"},{"location":"adapters/memory/#memory-session-backend","title":"Memory session backend","text":"<p>For OAuth state storage or database-session strategy in tests, use the memory session backend:</p> <pre><code>from fastauth.session_backends.memory import MemorySessionBackend\n\nconfig = FastAuthConfig(\n    ...,\n    oauth_state_store=MemorySessionBackend(),\n)\n</code></pre>"},{"location":"adapters/sqlalchemy/","title":"SQLAlchemy Adapter","text":"<p>The SQLAlchemy adapter is the recommended storage backend for production applications. It supports any SQLAlchemy-compatible async database.</p>"},{"location":"adapters/sqlalchemy/#supported-databases","title":"Supported databases","text":"Database Driver Connection URL prefix SQLite <code>aiosqlite</code> <code>sqlite+aiosqlite:///path/to/db.sqlite</code> PostgreSQL <code>asyncpg</code> <code>postgresql+asyncpg://user:pass@host/db</code> MySQL <code>aiomysql</code> <code>mysql+aiomysql://user:pass@host/db</code>"},{"location":"adapters/sqlalchemy/#install","title":"Install","text":"SQLite (dev)PostgreSQL <pre><code>pip install \"sreekarnv-fastauth[standard]\"\n# aiosqlite is included in the sqlalchemy extra\n</code></pre> <pre><code>pip install \"sreekarnv-fastauth[standard,postgresql]\"\n</code></pre>"},{"location":"adapters/sqlalchemy/#setup","title":"Setup","text":"<pre><code>from fastauth.adapters.sqlalchemy import SQLAlchemyAdapter\n\n# SQLite\nadapter = SQLAlchemyAdapter(engine_url=\"sqlite+aiosqlite:///./auth.db\")\n\n# PostgreSQL\nadapter = SQLAlchemyAdapter(\n    engine_url=\"postgresql+asyncpg://user:pass@localhost/mydb\"\n)\n</code></pre>"},{"location":"adapters/sqlalchemy/#using-an-existing-engine","title":"Using an existing engine","text":"<p>If you already manage an <code>AsyncEngine</code> elsewhere:</p> <pre><code>from sqlalchemy.ext.asyncio import create_async_engine\n\nengine = create_async_engine(\"postgresql+asyncpg://...\")\nadapter = SQLAlchemyAdapter(engine=engine)\n</code></pre>"},{"location":"adapters/sqlalchemy/#create-tables","title":"Create tables","text":"<p>Call <code>create_tables()</code> in your app's lifespan handler:</p> <pre><code>from contextlib import asynccontextmanager\nfrom fastapi import FastAPI\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    await adapter.create_tables()\n    yield\n\napp = FastAPI(lifespan=lifespan)\n</code></pre> <p>This is safe to call on every startup \u2014 it uses <code>CREATE TABLE IF NOT EXISTS</code> semantics.</p>"},{"location":"adapters/sqlalchemy/#sub-adapters","title":"Sub-adapters","text":"<p><code>SQLAlchemyAdapter</code> is a factory. Use its properties to get the individual adapter implementations:</p> <pre><code>config = FastAuthConfig(\n    adapter=adapter.user,        # required: UserAdapter\n    token_adapter=adapter.token, # needed for email verification / password reset\n    oauth_adapter=adapter.oauth, # needed for OAuth providers\n    ...\n)\n\n# RBAC adapter (set directly on the FastAuth instance)\nauth = FastAuth(config)\nauth.role_adapter = adapter.role\n</code></pre> Property Protocol When you need it <code>adapter.user</code> <code>UserAdapter</code> Always <code>adapter.token</code> <code>TokenAdapter</code> Email verification, password reset <code>adapter.session</code> <code>SessionAdapter</code> <code>session_strategy=\"database\"</code> <code>adapter.role</code> <code>RoleAdapter</code> RBAC <code>adapter.oauth</code> <code>OAuthAccountAdapter</code> OAuth providers"},{"location":"adapters/sqlalchemy/#migrations","title":"Migrations","text":"<p>FastAuth manages its own schema. For production, use Alembic instead of <code>create_tables()</code>:</p> <pre><code>pip install alembic\nalembic init alembic\n</code></pre> <p>Import <code>Base</code> from FastAuth in your Alembic <code>env.py</code>:</p> <pre><code>from fastauth.adapters.sqlalchemy.models import Base\ntarget_metadata = Base.metadata\n</code></pre>"},{"location":"concepts/adapters/","title":"Adapters","text":"<p>An adapter is the piece of FastAuth that talks to your database. Providers authenticate users; adapters persist and retrieve them.</p>"},{"location":"concepts/adapters/#the-adapter-pattern","title":"The adapter pattern","text":"<p>FastAuth defines adapters as Python <code>Protocol</code> classes. This means you never inherit from a FastAuth base class. You implement the required methods on your own class and pass it in \u2014 if the methods match the protocol, it works.</p> <p>This design lets FastAuth support any database engine without pulling in unwanted dependencies.</p>"},{"location":"concepts/adapters/#available-adapters","title":"Available adapters","text":""},{"location":"concepts/adapters/#sqlalchemyadapter","title":"SQLAlchemyAdapter","text":"<p>The recommended choice for most applications. Supports any SQLAlchemy-compatible async database:</p> <ul> <li>SQLite (development) via <code>aiosqlite</code></li> <li>PostgreSQL (production) via <code>asyncpg</code></li> <li>MySQL via <code>aiomysql</code></li> </ul> <p><code>SQLAlchemyAdapter</code> is a factory \u2014 one object gives you all the sub-adapters:</p> <pre><code>from fastauth.adapters.sqlalchemy import SQLAlchemyAdapter\n\nadapter = SQLAlchemyAdapter(engine_url=\"sqlite+aiosqlite:///./auth.db\")\n\nconfig = FastAuthConfig(\n    adapter=adapter.user,        # UserAdapter\n    token_adapter=adapter.token, # TokenAdapter (email/password reset tokens)\n    oauth_adapter=adapter.oauth, # OAuthAccountAdapter (linked social accounts)\n    # role_adapter set separately on auth.role_adapter\n)\n</code></pre> <p>See SQLAlchemy Adapter for the full guide.</p>"},{"location":"concepts/adapters/#memoryadapter","title":"MemoryAdapter","text":"<p>An in-memory adapter for testing. No database required.</p> <pre><code>from fastauth.adapters.memory import MemoryUserAdapter\n\nconfig = FastAuthConfig(\n    adapter=MemoryUserAdapter(),\n    ...\n)\n</code></pre> <p>See Memory Adapter.</p>"},{"location":"concepts/adapters/#sub-adapter-protocols","title":"Sub-adapter protocols","text":"<p>FastAuth splits storage responsibilities across several protocols:</p> Protocol Purpose Config field <code>UserAdapter</code> Create, read, update, delete users <code>adapter</code> <code>TokenAdapter</code> Persist one-time verification/reset tokens <code>token_adapter</code> <code>SessionAdapter</code> Store server-side sessions used internally <code>OAuthAccountAdapter</code> Link OAuth provider accounts to users <code>oauth_adapter</code> <code>RoleAdapter</code> Manage roles and permissions <code>auth.role_adapter</code> <p>You only need to configure the protocols relevant to your feature set. Email verification requires a <code>TokenAdapter</code>; OAuth requires an <code>OAuthAccountAdapter</code>; RBAC requires a <code>RoleAdapter</code>.</p>"},{"location":"concepts/adapters/#custom-adapters","title":"Custom adapters","text":"<p>If you use a database not supported by SQLAlchemy, or you have existing models, you can implement the protocol directly. See Custom Adapter.</p>"},{"location":"concepts/how-it-works/","title":"How it Works","text":"<p>FastAuth is a thin orchestration layer that connects providers, adapters, and transports together under a single FastAPI router.</p>"},{"location":"concepts/how-it-works/#architecture-overview","title":"Architecture overview","text":"<pre><code>graph TD\n    APP[\"FastAPI Application\"]\n\n    subgraph ROUTER[\"FastAuth Router  /auth/*\"]\n        ENDPOINTS[\"/signup \u00b7 /signin \u00b7 /signout \u00b7 /refresh \u00b7 /me\n/oauth/authorize \u00b7 /oauth/callback\n/email/verify \u00b7 /password/reset\"]\n    end\n\n    subgraph CORE[\"Core Logic\"]\n        CORELOGIC[\"tokens \u00b7 sessions \u00b7 rbac \u00b7 oauth \u00b7 emails \u00b7 jwks\"]\n    end\n\n    subgraph PROVIDERS[\"Providers\"]\n        direction LR\n        P1[\"Credentials\"]\n        P2[\"Google\"]\n        P3[\"GitHub\"]\n    end\n\n    subgraph ADAPTERS[\"Adapters\"]\n        direction LR\n        A1[\"SQLAlchemy\"]\n        A2[\"Memory\"]\n        A3[\"Custom\"]\n    end\n\n    subgraph TRANSPORTS[\"Transports\"]\n        direction LR\n        T1[\"SMTP\"]\n        T2[\"Console\"]\n        T3[\"Webhook\"]\n    end\n\n    APP --&gt; ROUTER\n    ROUTER --&gt; CORE\n    CORE --&gt; PROVIDERS &amp; ADAPTERS &amp; TRANSPORTS</code></pre>"},{"location":"concepts/how-it-works/#layers","title":"Layers","text":"Layer Responsibility API (router) HTTP endpoints \u2014 validates request bodies, calls core logic, returns responses Core Business logic \u2014 token creation, session management, RBAC checks Providers Authenticate users \u2014 verify a password or exchange an OAuth code Adapters Persist data \u2014 read/write users, tokens, sessions, roles in a database Transports Deliver emails \u2014 SMTP, webhook, or console (for dev)"},{"location":"concepts/how-it-works/#sign-in-flow-credentials","title":"Sign-in flow (credentials)","text":"<p>The sequence below shows what happens when a user posts <code>{ email, password }</code> to <code>/auth/signin</code>:</p> <pre><code>sequenceDiagram\n    participant C as Client\n    participant FA as FastAuth Router\n    participant P as CredentialsProvider\n    participant A as UserAdapter\n    participant T as Core/Tokens\n\n    C-&gt;&gt;FA: POST /auth/signin {email, password}\n    FA-&gt;&gt;P: authenticate({email, password})\n    P-&gt;&gt;A: get_user_by_email(email)\n    A--&gt;&gt;P: user record (or None)\n    P-&gt;&gt;P: verify_password(plain, hashed)\n    P--&gt;&gt;FA: user (or None)\n\n    alt authentication failed\n        FA--&gt;&gt;C: 401 Unauthorized\n    else hooks.allow_signin returns False\n        FA--&gt;&gt;C: 403 Forbidden\n    else success\n        FA-&gt;&gt;T: create_access_token(user)\n        FA-&gt;&gt;T: create_refresh_token(user)\n        T--&gt;&gt;FA: {access_token, refresh_token}\n        FA--&gt;&gt;C: 200 OK {access_token, refresh_token}\n    end</code></pre>"},{"location":"concepts/how-it-works/#request-authentication-flow","title":"Request authentication flow","text":"<p>When a protected route uses <code>Depends(require_auth)</code>:</p> <pre><code>sequenceDiagram\n    participant C as Client\n    participant R as Protected Route\n    participant D as require_auth dep\n    participant T as Core/Tokens\n    participant A as UserAdapter\n\n    C-&gt;&gt;R: GET /dashboard (Authorization: Bearer &lt;token&gt;)\n    R-&gt;&gt;D: Depends(require_auth)\n    D-&gt;&gt;D: extract token from header or cookie\n    D-&gt;&gt;T: decode_token(token_str)\n    T--&gt;&gt;D: claims {sub, type, exp}\n\n    alt token invalid or expired\n        D--&gt;&gt;C: 401 Unauthorized\n    else\n        D-&gt;&gt;A: get_user_by_id(claims[\"sub\"])\n        A--&gt;&gt;D: user record\n        D--&gt;&gt;R: user\n        R--&gt;&gt;C: 200 OK {response data}\n    end</code></pre>"},{"location":"concepts/how-it-works/#key-design-decisions","title":"Key design decisions","text":"<p>Protocol-based (duck typing) \u2014 Every adapter and transport is defined as a Python <code>Protocol</code>. You never inherit from a FastAuth base class; you just implement the right methods and pass your object in.</p> <p>Async-first \u2014 All adapters, providers, and hooks are <code>async</code>. FastAuth works natively with SQLAlchemy's async engine, aioredis, aiosmtplib, and httpx.</p> <p>Opt-in features \u2014 Email flows, RBAC, OAuth, JWKS \u2014 nothing is enabled unless you configure it. A minimal install has zero runtime dependencies beyond <code>cuid2</code> and <code>pydantic</code>.</p>"},{"location":"concepts/providers/","title":"Providers","text":"<p>A provider is the piece of FastAuth that knows how to authenticate a user. It doesn't store anything \u2014 that's the adapter's job \u2014 it just validates credentials or orchestrates an OAuth handshake and returns a user record.</p>"},{"location":"concepts/providers/#provider-types","title":"Provider types","text":"Type <code>auth_type</code> What it does <code>CredentialsProvider</code> <code>\"credentials\"</code> Verifies an email + password pair <code>GoogleProvider</code> <code>\"oauth\"</code> Handles Google OAuth 2.0 / OIDC <code>GitHubProvider</code> <code>\"oauth\"</code> Handles GitHub OAuth 2.0"},{"location":"concepts/providers/#multiple-providers-at-once","title":"Multiple providers at once","text":"<p>You can mix any number of providers:</p> <pre><code>from fastauth.providers.credentials import CredentialsProvider\nfrom fastauth.providers.google import GoogleProvider\nfrom fastauth.providers.github import GitHubProvider\n\nconfig = FastAuthConfig(\n    ...,\n    providers=[\n        CredentialsProvider(),\n        GoogleProvider(client_id=\"...\", client_secret=\"...\"),\n        GitHubProvider(client_id=\"...\", client_secret=\"...\"),\n    ],\n)\n</code></pre> <p>FastAuth routes requests to the right provider based on the endpoint called:</p> <ul> <li><code>POST /auth/signin</code> \u2192 CredentialsProvider</li> <li><code>GET /auth/oauth/authorize?provider=google</code> \u2192 GoogleProvider</li> <li><code>GET /auth/oauth/authorize?provider=github</code> \u2192 GitHubProvider</li> </ul>"},{"location":"concepts/providers/#when-to-use-each-provider","title":"When to use each provider","text":"<p>CredentialsProvider \u2014 the right default. Email + password with bcrypt/argon2 hashing, email verification, and password reset built in.</p> <p>GoogleProvider / GitHubProvider \u2014 when you want social login. Users authenticate on the provider's site and are redirected back with an OAuth code. FastAuth exchanges the code, fetches the user's profile, and creates (or links) a local user record.</p> <p>See the individual provider pages for setup details:</p> <ul> <li>Credentials</li> <li>Google OAuth</li> <li>GitHub OAuth</li> </ul>"},{"location":"concepts/tokens/","title":"Tokens &amp; Sessions","text":"<p>FastAuth issues two types of tokens on sign-in: an access token (short-lived) and a refresh token (long-lived). It supports two session strategies: stateless JWTs and server-side database sessions.</p>"},{"location":"concepts/tokens/#session-strategies","title":"Session strategies","text":""},{"location":"concepts/tokens/#jwt-default","title":"JWT (default)","text":"<p>Both tokens are signed JWTs. The server is stateless \u2014 no database lookup is needed to validate a request. The access token embeds the user's ID, and <code>require_auth</code> decodes and verifies it on every request.</p> <pre><code>config = FastAuthConfig(\n    ...,\n    session_strategy=\"jwt\",   # default\n)\n</code></pre> <p>Pros: Fast (no DB hit per request), easy to scale horizontally. Cons: Tokens cannot be revoked before they expire (use short TTLs).</p>"},{"location":"concepts/tokens/#database-sessions","title":"Database sessions","text":"<p>The server generates an opaque session ID, stores the session data in a <code>SessionBackend</code> (Redis, in-memory, or database), and returns the session ID in a cookie or JSON response.</p> <pre><code>from fastauth.session_backends.redis import RedisSessionBackend\n\nconfig = FastAuthConfig(\n    ...,\n    session_strategy=\"database\",\n    session_backend=RedisSessionBackend(url=\"redis://localhost:6379\"),\n)\n</code></pre> <p>Pros: Sessions can be revoked instantly (e.g. on logout or ban). Cons: Every authenticated request hits the session store.</p>"},{"location":"concepts/tokens/#token-lifetimes","title":"Token lifetimes","text":"<p>Configure in <code>JWTConfig</code>:</p> <pre><code>from fastauth.config import JWTConfig\n\njwt = JWTConfig(\n    access_token_ttl=900,        # 15 minutes (default)\n    refresh_token_ttl=2_592_000, # 30 days (default)\n)\n</code></pre> Token Default TTL Recommended range Access 15 minutes 5 min \u2013 1 hour Refresh 30 days 1 day \u2013 90 days"},{"location":"concepts/tokens/#token-delivery","title":"Token delivery","text":"Mode How tokens are returned When to use <code>\"json\"</code> (default) Response body <code>{ access_token, refresh_token }</code> SPAs, mobile apps, API clients <code>\"cookie\"</code> HttpOnly, Secure cookies Traditional web apps, same-origin frontends <pre><code>config = FastAuthConfig(\n    ...,\n    token_delivery=\"cookie\",\n    cookie_samesite=\"lax\",\n    cookie_secure=True,\n)\n</code></pre>"},{"location":"concepts/tokens/#refresh-flow","title":"Refresh flow","text":"<p>When the access token expires, the client posts the refresh token to <code>/auth/refresh</code>:</p> <pre><code>POST /auth/refresh\nAuthorization: Bearer &lt;refresh_token&gt;\n\n\u2192 200 OK\n{ \"access_token\": \"...\", \"refresh_token\": \"...\" }\n</code></pre> <p>FastAuth validates the refresh token, checks it's still live in the <code>token_adapter</code>, rotates it (issues a new pair), and returns the new tokens.</p>"},{"location":"concepts/tokens/#signing-algorithms","title":"Signing algorithms","text":"Algorithm Key material Use case <code>HS256</code> Shared secret (<code>secret</code> field) Single service <code>RS256</code> RSA private/public key pair Microservices (verify without the private key) <code>RS512</code> RSA private/public key pair Higher security RS variant <p>See JWT for RS256 setup and JWKS.</p>"},{"location":"features/cookies/","title":"Cookie Delivery","text":"<p>By default FastAuth returns tokens in the JSON response body. Switching to <code>\"cookie\"</code> delivery sets them as HttpOnly cookies instead \u2014 the browser sends them automatically on every request.</p>"},{"location":"features/cookies/#enable-cookie-delivery","title":"Enable cookie delivery","text":"<pre><code>config = FastAuthConfig(\n    ...,\n    token_delivery=\"cookie\",\n    cookie_samesite=\"lax\",     # default\n    cookie_httponly=True,      # default\n    # cookie_secure defaults to True in production (not debug),\n    # False in debug mode. Override explicitly if needed:\n    # cookie_secure=True,\n)\n</code></pre>"},{"location":"features/cookies/#how-it-works","title":"How it works","text":"<p>When <code>token_delivery=\"cookie\"</code>:</p> <ol> <li>Sign-in / sign-up / refresh \u2014 FastAuth sets two cookies on the response:</li> <li><code>access_token</code> (15 min, <code>HttpOnly</code>)</li> <li><code>refresh_token</code> (30 days, <code>HttpOnly</code>)</li> <li>Protected routes \u2014 <code>require_auth</code> reads the access token from the cookie first, then falls back to the <code>Authorization: Bearer</code> header.</li> <li>Sign-out \u2014 FastAuth clears both cookies.</li> </ol>"},{"location":"features/cookies/#cookie-options","title":"Cookie options","text":"Field Default Description <code>cookie_name_access</code> <code>\"access_token\"</code> Access-token cookie name <code>cookie_name_refresh</code> <code>\"refresh_token\"</code> Refresh-token cookie name <code>cookie_secure</code> <code>not debug</code> <code>Secure</code> flag (HTTPS only) <code>cookie_httponly</code> <code>True</code> <code>HttpOnly</code> flag (not accessible from JS) <code>cookie_samesite</code> <code>\"lax\"</code> <code>SameSite</code> policy <code>cookie_domain</code> <code>None</code> Domain scope"},{"location":"features/cookies/#samesite-policy","title":"SameSite policy","text":"Value Behaviour When to use <code>\"lax\"</code> Sent on same-site requests and top-level cross-site navigations Default \u2014 protects against CSRF for most apps <code>\"strict\"</code> Only sent on same-site requests Maximum protection, but breaks OAuth redirects <code>\"none\"</code> Always sent (requires <code>Secure=True</code>) Cross-origin frontends (e.g. SPA on different domain) <p>Cross-origin SPAs</p> <p>If your frontend is on a different domain (e.g. <code>app.example.com</code> \u2192 <code>api.example.com</code>), set <code>cookie_samesite=\"none\"</code> and <code>cookie_secure=True</code>. You'll also need to configure <code>cors_origins</code> and ensure your frontend sends credentials (<code>credentials: \"include\"</code> in fetch).</p>"},{"location":"features/cookies/#development-mode","title":"Development mode","text":"<pre><code>config = FastAuthConfig(\n    ...,\n    token_delivery=\"cookie\",\n    debug=True,  # sets cookie_secure=False so cookies work on http://localhost\n)\n</code></pre> <p>Danger</p> <p>Never set <code>debug=True</code> in production.</p>"},{"location":"features/email-verification/","title":"Email Verification","text":"<p>FastAuth can require users to verify their email address before they can sign in. The flow uses a one-time token stored via <code>token_adapter</code> and delivered by <code>email_transport</code>.</p>"},{"location":"features/email-verification/#prerequisites","title":"Prerequisites","text":"<pre><code>from fastauth.email_transports.console import ConsoleTransport  # dev\n# from fastauth.email_transports.smtp import SMTPTransport      # production\n\nconfig = FastAuthConfig(\n    ...,\n    token_adapter=adapter.token,          # persists verification tokens\n    email_transport=ConsoleTransport(),   # prints link to console in dev\n    base_url=\"https://your-app.com\",      # used in the verification link\n)\n</code></pre>"},{"location":"features/email-verification/#flow","title":"Flow","text":"<pre><code>sequenceDiagram\n    participant U as User\n    participant C as Client\n    participant FA as FastAuth\n    participant E as Email Transport\n    participant DB as Token Store\n\n    U-&gt;&gt;C: POST /auth/signup {email, password}\n    C-&gt;&gt;FA: POST /auth/signup\n    FA-&gt;&gt;DB: create user (is_email_verified=False)\n    FA-&gt;&gt;DB: create_token(type=\"email_verify\", token=&lt;uuid&gt;)\n    FA-&gt;&gt;E: send verification email with link\n    FA--&gt;&gt;C: 201 Created (user created, not yet verified)\n\n    U-&gt;&gt;U: Opens email, clicks verification link\n    U-&gt;&gt;C: GET /auth/email/verify?token=&lt;uuid&gt;\n    C-&gt;&gt;FA: GET /auth/email/verify?token=&lt;uuid&gt;\n    FA-&gt;&gt;DB: get_token(token, type=\"email_verify\")\n    alt token expired or not found\n        FA--&gt;&gt;C: 400 Bad Request\n    else valid\n        FA-&gt;&gt;DB: update_user(is_email_verified=True)\n        FA-&gt;&gt;DB: delete_token(token)\n        FA-&gt;&gt;FA: hooks.on_email_verify(user)\n        FA--&gt;&gt;C: 200 OK\n    end</code></pre>"},{"location":"features/email-verification/#endpoints","title":"Endpoints","text":"Method Path Description <code>POST</code> <code>/auth/email/request-verify</code> Re-send the verification email <code>GET</code> <code>/auth/email/verify?token=&lt;token&gt;</code> Verify the email and activate the account"},{"location":"features/email-verification/#resend-verification-email","title":"Resend verification email","text":"<p>If the user didn't receive the email:</p> <pre><code>curl -X POST http://localhost:8000/auth/email/request-verify \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"email\": \"alice@example.com\"}'\n</code></pre>"},{"location":"features/email-verification/#email-transports","title":"Email transports","text":"Transport Install Use case <code>ConsoleTransport</code> built-in Development \u2014 prints link to stdout <code>SMTPTransport</code> <code>email</code> extra Production SMTP server <code>WebhookTransport</code> built-in Custom HTTP endpoint / third-party service"},{"location":"features/email-verification/#smtp","title":"SMTP","text":"<pre><code>from fastauth.email_transports.smtp import SMTPTransport\n\ntransport = SMTPTransport(\n    hostname=\"smtp.sendgrid.net\",\n    port=587,\n    username=\"apikey\",\n    password=os.environ[\"SENDGRID_API_KEY\"],\n    use_tls=True,\n    sender=\"noreply@example.com\",\n)\n</code></pre>"},{"location":"features/email-verification/#hook","title":"Hook","text":"<p>Override <code>on_email_verify</code> to run custom logic after verification:</p> <pre><code>class MyHooks(EventHooks):\n    async def on_email_verify(self, user: UserData) -&gt; None:\n        await grant_welcome_credits(user[\"id\"])\n</code></pre>"},{"location":"features/hooks/","title":"Event Hooks","text":"<p>Event hooks let you plug custom logic into FastAuth's lifecycle \u2014 run side effects, block sign-ins, or add custom claims to JWTs.</p>"},{"location":"features/hooks/#setup","title":"Setup","text":"<p>Subclass <code>EventHooks</code> and pass an instance to <code>FastAuthConfig.hooks</code>:</p> <pre><code>from fastauth.core.protocols import EventHooks\nfrom fastauth.types import UserData\n\nclass MyHooks(EventHooks):\n    async def on_signup(self, user: UserData) -&gt; None:\n        await send_welcome_email(user[\"email\"])\n\n    async def on_signin(self, user: UserData, provider: str) -&gt; None:\n        await log_signin(user[\"id\"], provider)\n\nconfig = FastAuthConfig(..., hooks=MyHooks())\n</code></pre> <p>Only override the methods you need. All default implementations are no-ops (except <code>allow_signin</code> which returns <code>True</code> by default).</p>"},{"location":"features/hooks/#available-hooks","title":"Available hooks","text":""},{"location":"features/hooks/#lifecycle-events","title":"Lifecycle events","text":"Method When it's called Can modify return? <code>on_signup(user)</code> After a new user is created No <code>on_signin(user, provider)</code> After successful sign-in No <code>on_signout(user)</code> After sign-out No <code>on_token_refresh(user)</code> After token pair is refreshed No <code>on_email_verify(user)</code> After email verification No <code>on_password_reset(user)</code> After password reset No <code>on_oauth_link(user, provider)</code> After OAuth account linked No"},{"location":"features/hooks/#gate-hooks","title":"Gate hooks","text":"Method Returns Effect <code>allow_signin(user, provider)</code> <code>bool</code> Return <code>False</code> \u2192 HTTP 403"},{"location":"features/hooks/#mutation-hooks","title":"Mutation hooks","text":"Method Returns Effect <code>modify_jwt(token, user)</code> <code>dict</code> Returned dict is signed as the JWT payload <code>modify_session(session, user)</code> <code>dict</code> Returned dict is stored in the session backend"},{"location":"features/hooks/#examples","title":"Examples","text":""},{"location":"features/hooks/#block-banned-users","title":"Block banned users","text":"<pre><code>class MyHooks(EventHooks):\n    async def allow_signin(self, user: UserData, provider: str) -&gt; bool:\n        return not user.get(\"is_banned\", False)\n</code></pre>"},{"location":"features/hooks/#add-roles-to-jwt","title":"Add roles to JWT","text":"<pre><code>class MyHooks(EventHooks):\n    def __init__(self, role_adapter):\n        self.role_adapter = role_adapter\n\n    async def modify_jwt(self, token: dict, user: UserData) -&gt; dict:\n        token[\"roles\"] = await self.role_adapter.get_user_roles(user[\"id\"])\n        return token\n</code></pre>"},{"location":"features/hooks/#send-a-slack-notification-on-sign-up","title":"Send a Slack notification on sign-up","text":"<pre><code>import httpx\n\nclass MyHooks(EventHooks):\n    async def on_signup(self, user: UserData) -&gt; None:\n        async with httpx.AsyncClient() as client:\n            await client.post(\n                \"https://hooks.slack.com/...\",\n                json={\"text\": f\"New user: {user['email']}\"},\n            )\n</code></pre>"},{"location":"features/hooks/#assign-a-default-subscription-tier","title":"Assign a default subscription tier","text":"<pre><code>class MyHooks(EventHooks):\n    async def on_signup(self, user: UserData) -&gt; None:\n        await db.subscriptions.create(user_id=user[\"id\"], plan=\"free\")\n\n    async def modify_jwt(self, token: dict, user: UserData) -&gt; dict:\n        sub = await db.subscriptions.get(user_id=user[\"id\"])\n        token[\"plan\"] = sub.plan if sub else \"free\"\n        return token\n</code></pre>"},{"location":"features/jwt/","title":"JWT","text":"<p>FastAuth uses joserfc for JWT creation and validation. Both symmetric (HS256) and asymmetric (RS256/RS512) algorithms are supported.</p>"},{"location":"features/jwt/#hs256-default","title":"HS256 (default)","text":"<p>Uses a shared HMAC secret. Simple to set up, suitable for single-service deployments.</p> <pre><code>from fastauth import FastAuthConfig\nfrom fastauth.config import JWTConfig\n\nconfig = FastAuthConfig(\n    secret=\"my-secret-key\",   # must be long and random\n    jwt=JWTConfig(algorithm=\"HS256\"),  # default\n    ...\n)\n</code></pre> <p>Generate a secure secret:</p> <pre><code>fastauth generate-secret\n# \u2192 64-byte URL-safe base64 string\n</code></pre> <p>Warning</p> <p>The <code>secret</code> must be at least 32 characters for HS256. Never hard-code it \u2014 use environment variables.</p>"},{"location":"features/jwt/#rs256-rs512","title":"RS256 / RS512","text":"<p>Uses an RSA key pair. The private key signs tokens; the public key verifies them. This lets other services (microservices, CDNs) verify tokens without the private key.</p>"},{"location":"features/jwt/#generate-keys","title":"Generate keys","text":"<pre><code>openssl genrsa -out private.pem 2048\nopenssl rsa -in private.pem -pubout -out public.pem\n</code></pre> <p>Or use the helper script in the examples:</p> <pre><code>python examples/full/generate_keys.py\n</code></pre>"},{"location":"features/jwt/#configure","title":"Configure","text":"<pre><code>from pathlib import Path\n\nconfig = FastAuthConfig(\n    secret=\"still-required-for-the-config\",\n    jwt=JWTConfig(\n        algorithm=\"RS256\",\n        private_key=Path(\"private.pem\").read_text(),\n        public_key=Path(\"public.pem\").read_text(),\n    ),\n    ...\n)\n</code></pre>"},{"location":"features/jwt/#jwks-json-web-key-sets","title":"JWKS (JSON Web Key Sets)","text":"<p>When <code>jwks_enabled=True</code>, FastAuth exposes a <code>/.well-known/jwks.json</code> endpoint that publishes the current public key(s). Other services can fetch this endpoint to verify tokens without you distributing the public key file.</p> <pre><code>config = FastAuthConfig(\n    secret=\"...\",\n    jwt=JWTConfig(\n        algorithm=\"RS256\",\n        jwks_enabled=True,\n        key_rotation_interval=86400,  # rotate keys every 24 hours\n    ),\n    ...\n)\n</code></pre> <p>You must also call <code>initialize_jwks()</code> in your lifespan handler:</p> <pre><code>@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    await auth.initialize_jwks()\n    await adapter.create_tables()\n    yield\n</code></pre>"},{"location":"features/jwt/#token-structure","title":"Token structure","text":"<p>A decoded FastAuth access token looks like:</p> <pre><code>{\n  \"sub\": \"cuid2-user-id\",\n  \"type\": \"access\",\n  \"iat\": 1700000000,\n  \"exp\": 1700000900,\n  \"iss\": \"https://your-app.com\",\n  \"aud\": [\"your-app\"]\n}\n</code></pre> <p>Refresh tokens use <code>\"type\": \"refresh\"</code> and have a longer <code>exp</code>.</p>"},{"location":"features/jwt/#custom-claims","title":"Custom claims","text":"<p>Use the <code>modify_jwt</code> hook to add custom claims:</p> <pre><code>class MyHooks(EventHooks):\n    async def modify_jwt(self, token: dict, user: UserData) -&gt; dict:\n        token[\"email\"] = user[\"email\"]\n        token[\"plan\"] = user.get(\"plan\", \"free\")\n        return token\n</code></pre> <p>See Guides \u2192 Microservice JWT for a full RS256 + JWKS microservice example.</p>"},{"location":"features/oauth/","title":"OAuth Flow","text":"<p>FastAuth implements the OAuth 2.0 Authorization Code flow with CSRF protection via a random <code>state</code> parameter.</p>"},{"location":"features/oauth/#how-it-works","title":"How it works","text":"<pre><code>sequenceDiagram\n    participant U as User\n    participant C as Client App\n    participant FA as FastAuth\n    participant SS as State Store\n    participant P as OAuth Provider (Google/GitHub)\n\n    C-&gt;&gt;FA: GET /auth/oauth/authorize?provider=google\n    FA-&gt;&gt;FA: generate random state\n    FA-&gt;&gt;SS: write(state_id, {state}, ttl=600)\n    FA--&gt;&gt;C: 302 Redirect \u2192 provider auth URL (with state param)\n\n    U-&gt;&gt;P: Approves requested permissions\n    P--&gt;&gt;C: 302 Redirect \u2192 oauth_redirect_url?code=AUTH_CODE&amp;state=STATE\n\n    C-&gt;&gt;FA: GET /auth/oauth/callback?code=AUTH_CODE&amp;state=STATE\n    FA-&gt;&gt;SS: read(state_id) \u2014 CSRF check\n    FA-&gt;&gt;P: POST token endpoint (exchange code)\n    P--&gt;&gt;FA: {access_token, refresh_token, id_token}\n    FA-&gt;&gt;P: GET /user (fetch profile)\n    P--&gt;&gt;FA: {email, name, avatar, ...}\n\n    FA-&gt;&gt;FA: find existing user by email or OAuth account\n    alt new user\n        FA-&gt;&gt;FA: create_user(email, ...)\n        FA-&gt;&gt;FA: create_oauth_account(provider, account_id, user_id)\n        FA-&gt;&gt;FA: hooks.on_signup(user)\n    else existing user\n        FA-&gt;&gt;FA: hooks.on_oauth_link(user, provider) if new account\n    end\n\n    FA-&gt;&gt;FA: hooks.allow_signin(user, provider)\n    FA-&gt;&gt;FA: issue access + refresh tokens\n    FA--&gt;&gt;C: {access_token, refresh_token}</code></pre>"},{"location":"features/oauth/#configuration","title":"Configuration","text":"<pre><code>from fastauth.session_backends.memory import MemorySessionBackend\nfrom fastauth.providers.google import GoogleProvider\nfrom fastauth.providers.github import GitHubProvider\n\nconfig = FastAuthConfig(\n    providers=[\n        GoogleProvider(client_id=\"...\", client_secret=\"...\"),\n        GitHubProvider(client_id=\"...\", client_secret=\"...\"),\n    ],\n    oauth_adapter=adapter.oauth,           # persist linked accounts\n    oauth_state_store=MemorySessionBackend(),  # store CSRF state\n    oauth_redirect_url=\"https://your-app.com/auth/oauth/callback\",\n    ...\n)\n</code></pre>"},{"location":"features/oauth/#endpoints","title":"Endpoints","text":"Method Path Description <code>GET</code> <code>/auth/oauth/authorize?provider=&lt;id&gt;</code> Start the OAuth flow (redirects to provider) <code>GET</code> <code>/auth/oauth/callback?code=...&amp;state=...</code> Handle the provider callback"},{"location":"features/oauth/#csrf-protection","title":"CSRF protection","text":"<p>FastAuth generates a cryptographically random <code>state</code> value before each OAuth redirect, stores it in <code>oauth_state_store</code> with a 10-minute TTL, and verifies it when the provider redirects back. If the state is missing or doesn't match, the request is rejected with 400.</p> <p>Use <code>RedisSessionBackend</code> in production so state survives across multiple app instances:</p> <pre><code>from fastauth.session_backends.redis import RedisSessionBackend\n\nconfig = FastAuthConfig(\n    ...,\n    oauth_state_store=RedisSessionBackend(url=\"redis://localhost:6379\"),\n)\n</code></pre>"},{"location":"features/oauth/#account-linking","title":"Account linking","text":"<p>When a user logs in via OAuth and a local user with the same email already exists, FastAuth links the OAuth account to the existing user and calls <code>hooks.on_oauth_link</code>. No duplicate user is created.</p>"},{"location":"features/password-reset/","title":"Password Reset","text":"<p>FastAuth provides a two-step password reset flow: request a reset link via email, then submit a new password with the token from the link.</p>"},{"location":"features/password-reset/#prerequisites","title":"Prerequisites","text":"<p>Same as Email Verification \u2014 you need a <code>token_adapter</code> and <code>email_transport</code> configured.</p>"},{"location":"features/password-reset/#flow","title":"Flow","text":"<pre><code>sequenceDiagram\n    participant U as User\n    participant C as Client\n    participant FA as FastAuth\n    participant E as Email Transport\n    participant DB as Token Store\n\n    U-&gt;&gt;C: POST /auth/password/forgot {email}\n    C-&gt;&gt;FA: POST /auth/password/forgot\n    FA-&gt;&gt;DB: get_user_by_email(email)\n    alt user not found\n        FA--&gt;&gt;C: 200 OK (no information leak)\n    else user exists\n        FA-&gt;&gt;DB: create_token(type=\"password_reset\", token=&lt;uuid&gt;)\n        FA-&gt;&gt;E: send reset email with link\n        FA--&gt;&gt;C: 200 OK\n    end\n\n    U-&gt;&gt;U: Opens email, clicks reset link\n    U-&gt;&gt;C: POST /auth/password/reset {token, new_password}\n    C-&gt;&gt;FA: POST /auth/password/reset\n    FA-&gt;&gt;DB: get_token(token, type=\"password_reset\")\n    alt token expired or not found\n        FA--&gt;&gt;C: 400 Bad Request\n    else valid\n        FA-&gt;&gt;FA: hash new_password\n        FA-&gt;&gt;DB: set_hashed_password(user_id, hashed)\n        FA-&gt;&gt;DB: delete_token(token)\n        FA-&gt;&gt;FA: hooks.on_password_reset(user)\n        FA--&gt;&gt;C: 200 OK\n    end</code></pre>"},{"location":"features/password-reset/#endpoints","title":"Endpoints","text":"Method Path Body Description <code>POST</code> <code>/auth/password/forgot</code> <code>{\"email\": \"...\"}</code> Send a reset email <code>POST</code> <code>/auth/password/reset</code> <code>{\"token\": \"...\", \"password\": \"...\"}</code> Set a new password"},{"location":"features/password-reset/#request-a-reset","title":"Request a reset","text":"<pre><code>curl -X POST http://localhost:8000/auth/password/forgot \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"email\": \"alice@example.com\"}'\n</code></pre> <p>FastAuth always returns <code>200 OK</code> for this endpoint regardless of whether the email exists, to prevent user enumeration.</p>"},{"location":"features/password-reset/#submit-a-new-password","title":"Submit a new password","text":"<pre><code>curl -X POST http://localhost:8000/auth/password/reset \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"token\": \"&lt;token-from-email&gt;\", \"password\": \"newS3cur3P@ss!\"}'\n</code></pre>"},{"location":"features/password-reset/#hook","title":"Hook","text":"<pre><code>class MyHooks(EventHooks):\n    async def on_password_reset(self, user: UserData) -&gt; None:\n        await notify_user_of_password_change(user[\"email\"])\n</code></pre>"},{"location":"features/rbac/","title":"RBAC (Role-Based Access Control)","text":"<p>FastAuth includes a built-in role and permission system. Assign roles to users and protect routes with <code>require_role</code> or <code>require_permission</code>.</p>"},{"location":"features/rbac/#concepts","title":"Concepts","text":"<ul> <li>Role \u2014 a named group (e.g. <code>\"admin\"</code>, <code>\"editor\"</code>). A user can have multiple roles.</li> <li>Permission \u2014 a string label (e.g. <code>\"reports:read\"</code>, <code>\"users:delete\"</code>). Roles have sets of permissions. A user inherits all permissions from their roles.</li> </ul>"},{"location":"features/rbac/#setup","title":"Setup","text":"<p>You need a <code>RoleAdapter</code>. With the SQLAlchemy adapter:</p> <pre><code>auth = FastAuth(config)\nauth.role_adapter = adapter.role   # set after creating FastAuth instance\n</code></pre>"},{"location":"features/rbac/#protecting-routes","title":"Protecting routes","text":"<pre><code>from fastauth.api.deps import require_auth, require_role, require_permission\n\n# Must be authenticated\n@app.get(\"/dashboard\")\nasync def dashboard(user=Depends(require_auth)):\n    return {\"user\": user}\n\n# Must have the \"admin\" role\n@app.get(\"/admin\")\nasync def admin(user=Depends(require_role(\"admin\"))):\n    return {\"message\": \"admin panel\"}\n\n# Must have the \"reports:read\" permission (in any of their roles)\n@app.get(\"/reports\")\nasync def reports(user=Depends(require_permission(\"reports:read\"))):\n    return {\"data\": []}\n</code></pre>"},{"location":"features/rbac/#managing-roles-via-api","title":"Managing roles via API","text":"<p>FastAuth exposes RBAC management endpoints under <code>/auth/roles</code>:</p> Method Path Description <code>POST</code> <code>/auth/roles</code> Create a role <code>GET</code> <code>/auth/roles</code> List all roles <code>DELETE</code> <code>/auth/roles/{name}</code> Delete a role <code>POST</code> <code>/auth/roles/{name}/permissions</code> Add permissions to a role <code>DELETE</code> <code>/auth/roles/{name}/permissions</code> Remove permissions <code>POST</code> <code>/auth/roles/{name}/users/{user_id}</code> Assign role to user <code>DELETE</code> <code>/auth/roles/{name}/users/{user_id}</code> Revoke role from user"},{"location":"features/rbac/#seed-roles-on-startup","title":"Seed roles on startup","text":"<p>Define initial roles in <code>FastAuthConfig.roles</code> and they will be created on first startup:</p> <pre><code>config = FastAuthConfig(\n    ...,\n    roles=[\n        {\"name\": \"admin\",  \"permissions\": [\"users:read\", \"users:delete\", \"reports:read\"]},\n        {\"name\": \"editor\", \"permissions\": [\"posts:write\", \"posts:delete\"]},\n        {\"name\": \"viewer\", \"permissions\": [\"posts:read\", \"reports:read\"]},\n    ],\n    default_role=\"viewer\",  # automatically assigned to every new user\n)\n</code></pre>"},{"location":"features/rbac/#embedding-roles-in-the-jwt","title":"Embedding roles in the JWT","text":"<p>Use the <code>modify_jwt</code> hook to embed the user's roles in the access token so downstream services don't need a database call:</p> <pre><code>class MyHooks(EventHooks):\n    async def modify_jwt(self, token: dict, user: UserData) -&gt; dict:\n        if auth.role_adapter:\n            token[\"roles\"] = await auth.role_adapter.get_user_roles(user[\"id\"])\n        return token\n</code></pre>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>All FastAuth behaviour is controlled by two dataclasses: <code>FastAuthConfig</code> (main settings) and <code>JWTConfig</code> (token settings).</p>"},{"location":"getting-started/configuration/#fastauthconfig","title":"FastAuthConfig","text":"<pre><code>from fastauth import FastAuthConfig\nfrom fastauth.config import JWTConfig\n\nconfig = FastAuthConfig(\n    secret=\"...\",\n    providers=[...],\n    adapter=adapter.user,\n)\n</code></pre>"},{"location":"getting-started/configuration/#required-fields","title":"Required fields","text":"Field Type Description <code>secret</code> <code>str</code> HMAC secret for HS256 signing. Generate with <code>fastauth generate-secret</code>. <code>providers</code> <code>list</code> One or more provider instances (e.g. <code>CredentialsProvider()</code>). <code>adapter</code> <code>UserAdapter</code> Storage adapter for user records."},{"location":"getting-started/configuration/#token-delivery","title":"Token delivery","text":"Field Type Default Description <code>token_delivery</code> <code>\"json\"</code> | <code>\"cookie\"</code> <code>\"json\"</code> How tokens are returned to the client. <code>cookie_name_access</code> <code>str</code> <code>\"access_token\"</code> Access-token cookie name. <code>cookie_name_refresh</code> <code>str</code> <code>\"refresh_token\"</code> Refresh-token cookie name. <code>cookie_secure</code> <code>bool \\| None</code> <code>None</code> <code>Secure</code> flag override; defaults to <code>not debug</code>. <code>cookie_httponly</code> <code>bool</code> <code>True</code> Set the <code>HttpOnly</code> flag. <code>cookie_samesite</code> <code>\"lax\"</code> | <code>\"strict\"</code> | <code>\"none\"</code> <code>\"lax\"</code> <code>SameSite</code> policy. <code>cookie_domain</code> <code>str \\| None</code> <code>None</code> Optional domain scope."},{"location":"getting-started/configuration/#session-strategy","title":"Session strategy","text":"Field Type Default Description <code>session_strategy</code> <code>\"jwt\"</code> | <code>\"database\"</code> <code>\"jwt\"</code> Stateless JWTs or server-side sessions. <code>session_backend</code> <code>SessionBackend \\| None</code> <code>None</code> Required when <code>session_strategy=\"database\"</code>."},{"location":"getting-started/configuration/#oauth","title":"OAuth","text":"Field Type Default Description <code>oauth_adapter</code> <code>OAuthAccountAdapter \\| None</code> <code>None</code> Persists linked OAuth accounts. <code>oauth_state_store</code> <code>SessionBackend \\| None</code> <code>None</code> Stores OAuth CSRF state. <code>oauth_redirect_url</code> <code>str \\| None</code> <code>None</code> Callback URL registered with providers."},{"location":"getting-started/configuration/#email-tokens","title":"Email &amp; tokens","text":"Field Type Default Description <code>email_transport</code> <code>EmailTransport \\| None</code> <code>None</code> Transport for verification/reset emails. <code>token_adapter</code> <code>TokenAdapter \\| None</code> <code>None</code> Persists one-time verification tokens. <code>base_url</code> <code>str</code> <code>\"http://localhost:8000\"</code> Public app URL used in email links."},{"location":"getting-started/configuration/#rbac","title":"RBAC","text":"Field Type Default Description <code>roles</code> <code>list[dict] \\| None</code> <code>None</code> Seed role definitions. <code>default_role</code> <code>str \\| None</code> <code>None</code> Automatically assigned to new users."},{"location":"getting-started/configuration/#misc","title":"Misc","text":"Field Type Default Description <code>route_prefix</code> <code>str</code> <code>\"/auth\"</code> URL prefix for all FastAuth routes. <code>hooks</code> <code>EventHooks \\| None</code> <code>None</code> Lifecycle hook callbacks. <code>cors_origins</code> <code>list[str] \\| None</code> <code>None</code> Allowed CORS origins. <code>debug</code> <code>bool</code> <code>False</code> Relaxes cookie security. Never enable in production."},{"location":"getting-started/configuration/#jwtconfig","title":"JWTConfig","text":"<p>Pass a <code>JWTConfig</code> instance as <code>FastAuthConfig.jwt</code>:</p> <pre><code>from fastauth.config import JWTConfig\n\nconfig = FastAuthConfig(\n    ...,\n    jwt=JWTConfig(\n        algorithm=\"HS256\",\n        access_token_ttl=900,    # 15 minutes\n        refresh_token_ttl=86400, # 1 day\n    ),\n)\n</code></pre> Field Type Default Description <code>algorithm</code> <code>str</code> <code>\"HS256\"</code> Signing algorithm: <code>\"HS256\"</code>, <code>\"RS256\"</code>, <code>\"RS512\"</code>. <code>access_token_ttl</code> <code>int</code> <code>900</code> Access token lifetime in seconds. <code>refresh_token_ttl</code> <code>int</code> <code>2_592_000</code> Refresh token lifetime in seconds (30 days). <code>issuer</code> <code>str \\| None</code> <code>None</code> <code>iss</code> claim added to every token. <code>audience</code> <code>list[str] \\| None</code> <code>None</code> <code>aud</code> claim; validated on decode. <code>jwks_enabled</code> <code>bool</code> <code>False</code> Expose <code>/.well-known/jwks.json</code> and rotate keys. <code>key_rotation_interval</code> <code>int \\| None</code> <code>None</code> Seconds between RSA key rotations. <code>private_key</code> <code>str \\| None</code> <code>None</code> PEM RSA private key (RS256/RS512). <code>public_key</code> <code>str \\| None</code> <code>None</code> PEM RSA public key (RS256/RS512). <p>RS256 keys</p> <p>Generate an RSA key pair with: <pre><code>openssl genrsa -out private.pem 2048\nopenssl rsa -in private.pem -pubout -out public.pem\n</code></pre> Then load them into <code>JWTConfig</code>: <pre><code>JWTConfig(\n    algorithm=\"RS256\",\n    private_key=Path(\"private.pem\").read_text(),\n    public_key=Path(\"public.pem\").read_text(),\n)\n</code></pre></p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>FastAuth uses optional extras so you only install what you need.</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.11+</li> <li>An async-capable ASGI framework (FastAPI is included in <code>standard</code>)</li> </ul>"},{"location":"getting-started/installation/#extras","title":"Extras","text":"Extra What it adds Install <code>fastapi</code> FastAPI + Uvicorn <code>pip install \"sreekarnv-fastauth[fastapi]\"</code> <code>jwt</code> joserfc + cryptography (HS256/RS256 signing) <code>pip install \"sreekarnv-fastauth[jwt]\"</code> <code>oauth</code> httpx (Google, GitHub OAuth clients) <code>pip install \"sreekarnv-fastauth[oauth]\"</code> <code>sqlalchemy</code> SQLAlchemy + aiosqlite <code>pip install \"sreekarnv-fastauth[sqlalchemy]\"</code> <code>postgresql</code> asyncpg driver <code>pip install \"sreekarnv-fastauth[postgresql]\"</code> <code>redis</code> redis-py async client <code>pip install \"sreekarnv-fastauth[redis]\"</code> <code>argon2</code> argon2-cffi (password hashing) <code>pip install \"sreekarnv-fastauth[argon2]\"</code> <code>email</code> aiosmtplib + Jinja2 (SMTP transport) <code>pip install \"sreekarnv-fastauth[email]\"</code> <code>cli</code> typer + rich (CLI tool) <code>pip install \"sreekarnv-fastauth[cli]\"</code> <code>standard</code> fastapi + jwt + sqlalchemy + argon2 <code>pip install \"sreekarnv-fastauth[standard]\"</code> <code>all</code> everything above <code>pip install \"sreekarnv-fastauth[all]\"</code>"},{"location":"getting-started/installation/#common-install-combinations","title":"Common install combinations","text":"Basic (credentials only)With OAuthWith PostgreSQL + RedisEverything <pre><code>pip install \"sreekarnv-fastauth[standard]\"\n</code></pre> <pre><code>pip install \"sreekarnv-fastauth[standard,oauth]\"\n</code></pre> <pre><code>pip install \"sreekarnv-fastauth[standard,oauth,postgresql,redis,email]\"\n</code></pre> <pre><code>pip install \"sreekarnv-fastauth[all]\"\n</code></pre>"},{"location":"getting-started/installation/#verify-your-installation","title":"Verify your installation","text":"<p>The CLI <code>check</code> command prints the status of every optional dependency:</p> <pre><code>fastauth check\n</code></pre> <p>Example output:</p> <pre><code>FastAuth v0.3.0 \u2014 Dependency Status\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Extra      \u2503 Package        \u2503 Status                                \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 fastapi    \u2502 fastapi        \u2502 \u2713  installed                          \u2502\n\u2502 jwt        \u2502 joserfc        \u2502 \u2713  installed                          \u2502\n\u2502 oauth      \u2502 httpx          \u2502 \u2717  missing   pip install ...[oauth]   \u2502\n...\n</code></pre>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>This page walks you through a minimal working FastAuth application \u2014 email/password sign-up and sign-in with a SQLite database.</p>"},{"location":"getting-started/quick-start/#prerequisites","title":"Prerequisites","text":"<pre><code>pip install \"sreekarnv-fastauth[standard]\"\n</code></pre>"},{"location":"getting-started/quick-start/#the-code","title":"The code","text":"main.py<pre><code>from contextlib import asynccontextmanager\n\nfrom fastapi import Depends, FastAPI\n\nfrom fastauth import FastAuth, FastAuthConfig\nfrom fastauth.adapters.sqlalchemy import SQLAlchemyAdapter\nfrom fastauth.api.deps import require_auth\nfrom fastauth.providers.credentials import CredentialsProvider\nfrom fastauth.types import UserData\n\n# 1. Create the adapter (manages database tables)\nadapter = SQLAlchemyAdapter(engine_url=\"sqlite+aiosqlite:///./auth.db\")\n\n# 2. Configure FastAuth\nauth = FastAuth(FastAuthConfig(\n    secret=\"change-me-in-production\",  # generate with: fastauth generate-secret\n    providers=[CredentialsProvider()],\n    adapter=adapter.user,\n    token_adapter=adapter.token,       # needed for email verification tokens\n))\n\n# 3. Create the FastAPI app\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    await adapter.create_tables()      # creates tables on startup\n    yield\n\napp = FastAPI(lifespan=lifespan)\n\n# 4. Mount FastAuth \u2014 this registers all /auth/* routes\nauth.mount(app)\n\n# 5. Protect your own routes\n@app.get(\"/me\")\nasync def me(user: UserData = Depends(require_auth)):\n    return user\n</code></pre> <p>Run it:</p> <pre><code>uvicorn main:app --reload\n</code></pre>"},{"location":"getting-started/quick-start/#what-routes-are-registered","title":"What routes are registered?","text":"<p>After <code>auth.mount(app)</code>, the following endpoints are available at <code>/auth</code>:</p> Method Path Description <code>POST</code> <code>/auth/signup</code> Register a new user <code>POST</code> <code>/auth/signin</code> Sign in, receive access + refresh tokens <code>POST</code> <code>/auth/signout</code> Invalidate the current session <code>POST</code> <code>/auth/refresh</code> Exchange a refresh token for a new access token <code>GET</code> <code>/auth/me</code> Return the current authenticated user"},{"location":"getting-started/quick-start/#try-it-out","title":"Try it out","text":"<pre><code># Sign up\ncurl -X POST http://localhost:8000/auth/signup \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"email\": \"alice@example.com\", \"password\": \"s3cur3!\"}'\n\n# Sign in \u2014 note the access_token in the response\ncurl -X POST http://localhost:8000/auth/signin \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"email\": \"alice@example.com\", \"password\": \"s3cur3!\"}'\n\n# Call a protected route\ncurl http://localhost:8000/me \\\n  -H \"Authorization: Bearer &lt;your_access_token&gt;\"\n</code></pre>"},{"location":"getting-started/quick-start/#next-steps","title":"Next steps","text":"<ul> <li>Configuration \u2014 learn every config option</li> <li>Providers \u2014 customise the credentials provider</li> <li>Features \u2192 Cookie Delivery \u2014 use HttpOnly cookies instead of JSON tokens</li> <li>Guides \u2192 Basic App \u2014 a full walkthrough with RBAC and email verification</li> </ul>"},{"location":"guides/basic/","title":"Guide: Basic App","text":"<p>This guide walks through the full <code>examples/basic</code> application \u2014 a FastAPI app with email/password authentication, email verification, and RBAC.</p>"},{"location":"guides/basic/#what-were-building","title":"What we're building","text":"<ul> <li>Email + password sign-up and sign-in</li> <li>Email verification (printed to console in dev)</li> <li>Protected routes requiring authentication, roles, and permissions</li> <li>SQLite database via SQLAlchemy</li> </ul>"},{"location":"guides/basic/#full-source","title":"Full source","text":"examples/basic/main.py<pre><code>from contextlib import asynccontextmanager\n\nfrom fastapi import Depends, FastAPI\n\nfrom fastauth import FastAuth, FastAuthConfig\nfrom fastauth.adapters.sqlalchemy import SQLAlchemyAdapter\nfrom fastauth.api.deps import require_auth, require_permission, require_role\nfrom fastauth.email_transports.console import ConsoleTransport\nfrom fastauth.providers.credentials import CredentialsProvider\nfrom fastauth.types import UserData\n\nadapter = SQLAlchemyAdapter(engine_url=\"sqlite+aiosqlite:///./auth.db\")\n\nconfig = FastAuthConfig(\n    secret=\"super-secret-change-me-in-production\",\n    providers=[CredentialsProvider()],\n    adapter=adapter.user,\n    token_adapter=adapter.token,\n    email_transport=ConsoleTransport(),\n    base_url=\"http://localhost:8000\",\n)\n\nauth = FastAuth(config)\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    await adapter.create_tables()\n    yield\n\n\napp = FastAPI(title=\"FastAuth Basic Example\", lifespan=lifespan)\nauth.mount(app)\n\n\n@app.get(\"/dashboard\")\nasync def dashboard(user: UserData = Depends(require_auth)):\n    return {\"message\": f\"Hello, {user['email']}\", \"user\": user}\n\n\n@app.get(\"/admin\")\nasync def admin_area(user: UserData = Depends(require_role(\"admin\"))):\n    return {\"message\": \"Welcome, admin\", \"user_id\": user[\"id\"]}\n\n\n@app.get(\"/reports\")\nasync def reports(user: UserData = Depends(require_permission(\"reports:read\"))):\n    return {\"message\": \"Here are your reports\", \"user_id\": user[\"id\"]}\n</code></pre>"},{"location":"guides/basic/#step-by-step-walkthrough","title":"Step-by-step walkthrough","text":""},{"location":"guides/basic/#1-create-the-adapter","title":"1. Create the adapter","text":"<pre><code>adapter = SQLAlchemyAdapter(engine_url=\"sqlite+aiosqlite:///./auth.db\")\n</code></pre> <p><code>SQLAlchemyAdapter</code> wraps an async SQLAlchemy engine. We use SQLite here \u2014 swap the URL for PostgreSQL in production. The <code>.user</code> and <code>.token</code> properties return the adapter implementations we need.</p>"},{"location":"guides/basic/#2-configure-fastauth","title":"2. Configure FastAuth","text":"<pre><code>config = FastAuthConfig(\n    secret=\"...\",                         # HMAC signing secret\n    providers=[CredentialsProvider()],    # email + password\n    adapter=adapter.user,                 # reads/writes users\n    token_adapter=adapter.token,          # stores verification tokens\n    email_transport=ConsoleTransport(),   # prints emails to stdout\n    base_url=\"http://localhost:8000\",     # used in email links\n)\n</code></pre> <p><code>ConsoleTransport</code> is great for development \u2014 it prints the verification link to the terminal instead of sending an email.</p>"},{"location":"guides/basic/#3-mount-routes","title":"3. Mount routes","text":"<pre><code>auth.mount(app)\n</code></pre> <p>This registers all <code>/auth/*</code> endpoints. Open <code>/docs</code> after starting the app to see the interactive documentation.</p>"},{"location":"guides/basic/#4-protect-your-own-routes","title":"4. Protect your own routes","text":"<pre><code>@app.get(\"/dashboard\")\nasync def dashboard(user: UserData = Depends(require_auth)):\n    return {\"message\": f\"Hello, {user['email']}\"}\n</code></pre> <p><code>require_auth</code> extracts and validates the JWT from the <code>Authorization</code> header (or cookie). If there's no valid token, it returns HTTP 401.</p> <pre><code>@app.get(\"/admin\")\nasync def admin_area(user: UserData = Depends(require_role(\"admin\"))):\n    ...\n</code></pre> <p><code>require_role(\"admin\")</code> first calls <code>require_auth</code>, then checks that the user has the <code>admin</code> role.</p>"},{"location":"guides/basic/#run-it","title":"Run it","text":"<pre><code>pip install \"sreekarnv-fastauth[standard]\"\nuvicorn main:app --reload\n</code></pre> <p>Then visit <code>http://localhost:8000/docs</code>.</p>"},{"location":"guides/basic/#generating-a-production-secret","title":"Generating a production secret","text":"<pre><code>fastauth generate-secret\n</code></pre> <p>Paste the output into your environment variables, never into source code.</p>"},{"location":"guides/microservice/","title":"Guide: Microservice JWT","text":"<p>This guide shows how to use RS256 + JWKS so a resource service can verify FastAuth tokens without sharing the private key, based on <code>examples/jwt-microservice</code>.</p>"},{"location":"guides/microservice/#the-pattern","title":"The pattern","text":"<pre><code>graph LR\n    CLIENT[\"Client\"]\n\n    subgraph AUTH[\"Auth Service  :8000\"]\n        SIGNIN[\"POST /auth/signin\nsigns with RSA private key\"]\n        JWKS_EP[\"GET /.well-known/jwks.json\npublic key endpoint\"]\n    end\n\n    subgraph RESOURCE[\"Resource Service  :8001\"]\n        DATA[\"GET /api/data\nverifies with RSA public key\"]\n    end\n\n    CLIENT --&gt;|\"1. POST /auth/signin\"| SIGNIN\n    SIGNIN --&gt;|\"2. access_token\"| CLIENT\n    CLIENT --&gt;|\"3. Bearer token\"| DATA\n    DATA -.-&gt;|\"4. fetch JWKS once\"| JWKS_EP\n    JWKS_EP -.-&gt;|\"5. public key\"| DATA</code></pre>"},{"location":"guides/microservice/#auth-service","title":"Auth service","text":""},{"location":"guides/microservice/#generate-keys","title":"Generate keys","text":"<pre><code>openssl genrsa -out private_key.pem 2048\nopenssl rsa -in private_key.pem -pubout -out public_key.pem\n</code></pre>"},{"location":"guides/microservice/#configure","title":"Configure","text":"auth_service.py<pre><code>from contextlib import asynccontextmanager\nfrom pathlib import Path\n\nfrom fastapi import FastAPI\nfrom fastauth import FastAuth, FastAuthConfig, JWTConfig\nfrom fastauth.adapters.sqlalchemy import SQLAlchemyAdapter\nfrom fastauth.providers.credentials import CredentialsProvider\n\n_PRIVATE_KEY = Path(\"private_key.pem\").read_text()\n_PUBLIC_KEY = Path(\"public_key.pem\").read_text()\n\nadapter = SQLAlchemyAdapter(engine_url=\"sqlite+aiosqlite:///./auth.db\")\n\nconfig = FastAuthConfig(\n    secret=\"unused-for-rs256-but-required\",\n    providers=[CredentialsProvider()],\n    adapter=adapter.user,\n    token_adapter=adapter.token,\n    jwt=JWTConfig(\n        algorithm=\"RS256\",\n        private_key=_PRIVATE_KEY,\n        public_key=_PUBLIC_KEY,\n        jwks_enabled=True,       # exposes /.well-known/jwks.json\n        access_token_ttl=900,\n    ),\n    base_url=\"http://localhost:8000\",\n)\n\nauth = FastAuth(config)\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    await adapter.create_tables()\n    await auth.initialize_jwks()   # required for JWKS mode\n    yield\n\n\napp = FastAPI(title=\"Auth Service\")\nauth.mount(app)\n</code></pre> <p>Run on port 8000:</p> <pre><code>uvicorn auth_service:app --port 8000 --reload\n</code></pre>"},{"location":"guides/microservice/#resource-service","title":"Resource service","text":"<p>The resource service fetches the public key from the JWKS endpoint and uses it to verify incoming tokens. It does not need the private key.</p> resource_service.py<pre><code>import httpx\nfrom fastapi import FastAPI, HTTPException, Request, status\nfrom joserfc import jwt\nfrom joserfc.jwk import KeySet\n\napp = FastAPI(title=\"Resource Service\")\n\n_jwks: KeySet | None = None\n\nasync def get_jwks() -&gt; KeySet:\n    global _jwks\n    if _jwks is None:\n        async with httpx.AsyncClient() as client:\n            response = await client.get(\"http://localhost:8000/.well-known/jwks.json\")\n            _jwks = KeySet.import_key_set(response.json())\n    return _jwks\n\nasync def verify_token(token_str: str) -&gt; dict:\n    jwks = await get_jwks()\n    try:\n        token = jwt.decode(token_str, jwks)\n        token.validate()\n        return token.claims\n    except Exception:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED)\n\n@app.get(\"/api/data\")\nasync def protected_data(request: Request):\n    auth_header = request.headers.get(\"Authorization\", \"\")\n    if not auth_header.startswith(\"Bearer \"):\n        raise HTTPException(status_code=401)\n    claims = await verify_token(auth_header[7:])\n    return {\"user_id\": claims[\"sub\"], \"data\": \"secret data\"}\n</code></pre> <p>Run on port 8001:</p> <pre><code>uvicorn resource_service:app --port 8001 --reload\n</code></pre>"},{"location":"guides/microservice/#try-it","title":"Try it","text":"<pre><code># Sign in via auth service\nTOKEN=$(curl -s -X POST http://localhost:8000/auth/signin \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"email\":\"alice@example.com\",\"password\":\"s3cr3t\"}' \\\n  | jq -r .access_token)\n\n# Call resource service with that token\ncurl http://localhost:8001/api/data \\\n  -H \"Authorization: Bearer $TOKEN\"\n</code></pre>"},{"location":"guides/microservice/#key-rotation","title":"Key rotation","text":"<p>When <code>jwks_enabled=True</code> and <code>key_rotation_interval</code> is set, FastAuth generates a new RSA key pair after the interval expires. The old key is kept in the JWKS response during a transition window so in-flight tokens continue to validate.</p> <pre><code>JWTConfig(\n    algorithm=\"RS256\",\n    jwks_enabled=True,\n    key_rotation_interval=86400,  # rotate every 24 hours\n)\n</code></pre> <p>Resource services should re-fetch the JWKS when they encounter an unknown key ID (<code>kid</code>).</p>"},{"location":"guides/oauth/","title":"Guide: Adding OAuth","text":"<p>This guide extends the basic credentials app to add Google and GitHub social login, based on <code>examples/oauth</code>.</p>"},{"location":"guides/oauth/#install","title":"Install","text":"<pre><code>pip install \"sreekarnv-fastauth[standard,oauth]\"\n</code></pre>"},{"location":"guides/oauth/#setup-providers","title":"Setup providers","text":"examples/oauth/main.py<pre><code>import os\nfrom contextlib import asynccontextmanager\n\nfrom fastapi import FastAPI\n\nfrom fastauth import FastAuth, FastAuthConfig\nfrom fastauth.adapters.sqlalchemy import SQLAlchemyAdapter\nfrom fastauth.email_transports.console import ConsoleTransport\nfrom fastauth.providers.credentials import CredentialsProvider\nfrom fastauth.providers.github import GitHubProvider\nfrom fastauth.providers.google import GoogleProvider\nfrom fastauth.session_backends.memory import MemorySessionBackend\n\nadapter = SQLAlchemyAdapter(engine_url=\"sqlite+aiosqlite:///./auth.db\")\n\nconfig = FastAuthConfig(\n    secret=os.environ[\"SECRET\"],\n    providers=[\n        CredentialsProvider(),\n        GoogleProvider(\n            client_id=os.environ[\"GOOGLE_CLIENT_ID\"],\n            client_secret=os.environ[\"GOOGLE_CLIENT_SECRET\"],\n        ),\n        GitHubProvider(\n            client_id=os.environ[\"GITHUB_CLIENT_ID\"],\n            client_secret=os.environ[\"GITHUB_CLIENT_SECRET\"],\n        ),\n    ],\n    adapter=adapter.user,\n    token_adapter=adapter.token,\n    oauth_adapter=adapter.oauth,                      # stores linked accounts\n    oauth_state_store=MemorySessionBackend(),          # CSRF state (use Redis in prod)\n    oauth_redirect_url=\"http://localhost:8000/auth/oauth/callback\",\n    email_transport=ConsoleTransport(),\n    base_url=\"http://localhost:8000\",\n)\n\nauth = FastAuth(config)\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    await adapter.create_tables()\n    yield\n\n\napp = FastAPI(title=\"FastAuth OAuth Example\", lifespan=lifespan)\nauth.mount(app)\n</code></pre>"},{"location":"guides/oauth/#whats-different-from-the-basic-app","title":"What's different from the basic app?","text":"Addition Why <code>GoogleProvider(...)</code> Adds Google OAuth 2.0 <code>GitHubProvider(...)</code> Adds GitHub OAuth 2.0 <code>oauth_adapter=adapter.oauth</code> Persists the link between a provider account and a local user <code>oauth_state_store=MemorySessionBackend()</code> Stores the CSRF state token during the OAuth dance <code>oauth_redirect_url=\"...\"</code> The callback URL that providers redirect to"},{"location":"guides/oauth/#register-the-redirect-url","title":"Register the redirect URL","text":""},{"location":"guides/oauth/#google","title":"Google","text":"<ol> <li>Open Google Cloud Console \u2192 Credentials</li> <li>Edit your OAuth 2.0 client</li> <li>Add <code>http://localhost:8000/auth/oauth/callback</code> to Authorized redirect URIs</li> </ol>"},{"location":"guides/oauth/#github","title":"GitHub","text":"<ol> <li>Open GitHub Developer Settings \u2192 OAuth Apps</li> <li>Set Authorization callback URL to <code>http://localhost:8000/auth/oauth/callback</code></li> </ol>"},{"location":"guides/oauth/#trigger-the-oauth-flow","title":"Trigger the OAuth flow","text":"<p>From your frontend, redirect the user to:</p> <pre><code>GET /auth/oauth/authorize?provider=google\nGET /auth/oauth/authorize?provider=github\n</code></pre> <p>FastAuth handles the rest \u2014 CSRF state, code exchange, user creation/linking, and token issuance.</p>"},{"location":"guides/oauth/#environment-variables","title":"Environment variables","text":"<pre><code>export SECRET=$(fastauth generate-secret)\nexport GOOGLE_CLIENT_ID=...\nexport GOOGLE_CLIENT_SECRET=...\nexport GITHUB_CLIENT_ID=...\nexport GITHUB_CLIENT_SECRET=...\nuvicorn main:app --reload\n</code></pre>"},{"location":"guides/oauth/#production-notes","title":"Production notes","text":"<ul> <li>Replace <code>MemorySessionBackend()</code> with <code>RedisSessionBackend(...)</code> so OAuth state survives across multiple processes.</li> <li>Use HTTPS for <code>oauth_redirect_url</code> in production.</li> </ul>"},{"location":"guides/production/","title":"Production Checklist","text":"<p>A checklist of everything you should review before deploying FastAuth to production.</p>"},{"location":"guides/production/#secrets","title":"Secrets","text":"<ul> <li>[ ] Generate a strong secret: <code>fastauth generate-secret</code> \u2014 use the output, don't make one up</li> <li>[ ] Store secrets in environment variables \u2014 never commit secrets to source control</li> <li>[ ] Use different secrets per environment (dev, staging, prod)</li> <li>[ ] For RS256: keep the private key in a secrets manager (AWS Secrets Manager, Vault, etc.)</li> </ul> <pre><code>import os\n\nconfig = FastAuthConfig(\n    secret=os.environ[\"FASTAUTH_SECRET\"],\n    ...\n)\n</code></pre>"},{"location":"guides/production/#https","title":"HTTPS","text":"<ul> <li>[ ] All traffic over HTTPS \u2014 never serve auth endpoints over plain HTTP in production</li> <li>[ ] Set <code>cookie_secure=True</code> (it defaults to <code>True</code> when <code>debug=False</code>)</li> <li>[ ] Update <code>base_url</code> to your HTTPS domain for correct email links</li> </ul> <pre><code>config = FastAuthConfig(\n    ...,\n    base_url=\"https://api.example.com\",\n    debug=False,  # default \u2014 ensures Secure cookies\n)\n</code></pre>"},{"location":"guides/production/#database","title":"Database","text":"<ul> <li>[ ] Use PostgreSQL (or another production DB) instead of SQLite</li> <li>[ ] Use Alembic for migrations instead of <code>create_tables()</code> in production</li> <li>[ ] Set up connection pooling (<code>pool_size</code>, <code>max_overflow</code> on <code>create_async_engine</code>)</li> </ul> <pre><code>from sqlalchemy.ext.asyncio import create_async_engine\nfrom fastauth.adapters.sqlalchemy import SQLAlchemyAdapter\n\nengine = create_async_engine(\n    os.environ[\"DATABASE_URL\"],\n    pool_size=10,\n    max_overflow=20,\n)\nadapter = SQLAlchemyAdapter(engine=engine)\n</code></pre>"},{"location":"guides/production/#session-storage","title":"Session storage","text":"<ul> <li>[ ] Use Redis for <code>oauth_state_store</code> and <code>session_backend</code> \u2014 memory backends don't survive restarts or scale across instances</li> </ul> <pre><code>from fastauth.session_backends.redis import RedisSessionBackend\n\nbackend = RedisSessionBackend(url=os.environ[\"REDIS_URL\"])\nconfig = FastAuthConfig(\n    ...,\n    oauth_state_store=backend,\n    session_backend=backend,  # if using database sessions\n)\n</code></pre>"},{"location":"guides/production/#cookies","title":"Cookies","text":"<ul> <li>[ ] Set <code>cookie_secure=True</code> (default when not in debug mode)</li> <li>[ ] Set <code>cookie_httponly=True</code> (default) \u2014 prevents JS access</li> <li>[ ] Review <code>cookie_samesite</code> \u2014 <code>\"lax\"</code> for same-origin apps, <code>\"none\"</code> for cross-origin SPAs</li> <li>[ ] Set <code>cookie_domain</code> if you share cookies across subdomains</li> </ul>"},{"location":"guides/production/#token-lifetimes","title":"Token lifetimes","text":"<ul> <li>[ ] Short access token TTL \u2014 15 minutes (default) is a good baseline</li> <li>[ ] Consider shorter TTLs for high-security applications (5 minutes)</li> <li>[ ] Rotate refresh tokens on every refresh (FastAuth does this automatically)</li> </ul>"},{"location":"guides/production/#cors","title":"CORS","text":"<ul> <li>[ ] Set <code>cors_origins</code> to only the domains that need access</li> </ul> <pre><code>config = FastAuthConfig(\n    ...,\n    cors_origins=[\"https://app.example.com\"],\n)\n</code></pre>"},{"location":"guides/production/#email","title":"Email","text":"<ul> <li>[ ] Use SMTP or a transactional email service (SendGrid, AWS SES, Postmark)</li> <li>[ ] Never use <code>ConsoleTransport</code> in production</li> <li>[ ] Test email delivery before going live</li> </ul> <pre><code>from fastauth.email_transports.smtp import SMTPTransport\n\ntransport = SMTPTransport(\n    hostname=os.environ[\"SMTP_HOST\"],\n    port=587,\n    username=os.environ[\"SMTP_USER\"],\n    password=os.environ[\"SMTP_PASS\"],\n    use_tls=True,\n    sender=\"noreply@example.com\",\n)\n</code></pre>"},{"location":"guides/production/#rate-limiting","title":"Rate limiting","text":"<p>FastAuth does not include built-in rate limiting. Add it at the infrastructure level:</p> <ul> <li>Reverse proxy: nginx rate limiting, Caddy's rate-limit plugin</li> <li>API gateway: AWS API Gateway, Kong, Traefik</li> <li>Application: <code>slowapi</code> (FastAPI-compatible rate limiter)</li> </ul> <p>Consider rate limiting these endpoints in particular: - <code>POST /auth/signin</code> \u2014 prevent brute-force attacks - <code>POST /auth/password/forgot</code> \u2014 prevent email flooding - <code>POST /auth/signup</code> \u2014 prevent account spam</p>"},{"location":"guides/production/#monitoring","title":"Monitoring","text":"<ul> <li>[ ] Hook into <code>on_signin</code>, <code>on_signup</code> to emit metrics or audit logs</li> <li>[ ] Monitor failed sign-in rates for anomaly detection</li> <li>[ ] Set up alerts for database connection pool exhaustion</li> </ul>"},{"location":"providers/credentials/","title":"Credentials Provider","text":"<p>The built-in email/password provider. No extra dependencies required (password hashing uses <code>argon2-cffi</code> from the <code>argon2</code> extra).</p>"},{"location":"providers/credentials/#setup","title":"Setup","text":"<pre><code>from fastauth.providers.credentials import CredentialsProvider\n\nconfig = FastAuthConfig(\n    providers=[CredentialsProvider()],\n    ...\n)\n</code></pre>"},{"location":"providers/credentials/#endpoints","title":"Endpoints","text":"Method Path Description <code>POST</code> <code>/auth/signup</code> Register a new user <code>POST</code> <code>/auth/signin</code> Sign in with email + password <code>POST</code> <code>/auth/signout</code> Sign out (invalidate session/token) <code>POST</code> <code>/auth/refresh</code> Refresh token pair <code>GET</code> <code>/auth/me</code> Return current user"},{"location":"providers/credentials/#sign-up","title":"Sign up","text":"<pre><code>curl -X POST http://localhost:8000/auth/signup \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"email\": \"alice@example.com\", \"password\": \"s3cur3P@ss!\"}'\n</code></pre> <p>Response:</p> <pre><code>{\n  \"access_token\": \"eyJ...\",\n  \"refresh_token\": \"eyJ...\",\n  \"token_type\": \"bearer\"\n}\n</code></pre>"},{"location":"providers/credentials/#sign-in","title":"Sign in","text":"<pre><code>curl -X POST http://localhost:8000/auth/signin \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"email\": \"alice@example.com\", \"password\": \"s3cur3P@ss!\"}'\n</code></pre>"},{"location":"providers/credentials/#email-verification","title":"Email verification","text":"<p>When an <code>email_transport</code> and <code>token_adapter</code> are configured, FastAuth automatically sends a verification email on sign-up. The user must click the link before they can sign in.</p> Method Path Description <code>POST</code> <code>/auth/email/request-verify</code> Re-send the verification email <code>GET</code> <code>/auth/email/verify?token=&lt;token&gt;</code> Mark email as verified <p>See Email Verification for the full flow.</p>"},{"location":"providers/credentials/#password-reset","title":"Password reset","text":"Method Path Description <code>POST</code> <code>/auth/password/forgot</code> Send a reset email <code>POST</code> <code>/auth/password/reset</code> Set a new password using the reset token <p>See Password Reset.</p>"},{"location":"providers/credentials/#password-hashing","title":"Password hashing","text":"<p>FastAuth uses Argon2id by default (<code>argon2-cffi</code>). If Argon2 is not installed it falls back to bcrypt.</p> <p>Install Argon2</p> <pre><code>pip install \"sreekarnv-fastauth[argon2]\"\n</code></pre>"},{"location":"providers/github/","title":"GitHub OAuth Provider","text":"<p>Authenticate users with their GitHub accounts.</p>"},{"location":"providers/github/#prerequisites","title":"Prerequisites","text":"<pre><code>pip install \"sreekarnv-fastauth[standard,oauth]\"\n</code></pre> <p>Register a GitHub OAuth App at https://github.com/settings/applications/new:</p> <ul> <li>Homepage URL: <code>https://your-domain.com</code></li> <li>Authorization callback URL: <code>https://your-domain.com/auth/oauth/callback</code></li> </ul> <p>Copy the Client ID and generate a Client Secret.</p>"},{"location":"providers/github/#setup","title":"Setup","text":"<pre><code>import os\nfrom fastauth.providers.github import GitHubProvider\n\nconfig = FastAuthConfig(\n    providers=[\n        GitHubProvider(\n            client_id=os.environ[\"GITHUB_CLIENT_ID\"],\n            client_secret=os.environ[\"GITHUB_CLIENT_SECRET\"],\n        ),\n    ],\n    oauth_adapter=adapter.oauth,\n    oauth_state_store=MemorySessionBackend(),\n    oauth_redirect_url=\"https://your-domain.com/auth/oauth/callback\",\n    ...\n)\n</code></pre>"},{"location":"providers/github/#email-policy","title":"Email policy","text":"<p>GitHub accounts may have a private email address. FastAuth fetches the user's primary, verified email from the GitHub API. If no public email is available it falls back to the verified primary email from the <code>/user/emails</code> endpoint.</p> <p>Note</p> <p>Users without a verified email on GitHub cannot sign in until they add and verify one.</p>"},{"location":"providers/github/#flow","title":"Flow","text":"<p>The flow is the same as Google OAuth \u2014 authorize \u2192 callback \u2192 token pair. The provider ID for the <code>authorize</code> endpoint is <code>github</code>:</p> <pre><code>GET /auth/oauth/authorize?provider=github\n</code></pre>"},{"location":"providers/google/","title":"Google OAuth Provider","text":"<p>Authenticate users with their Google accounts via OAuth 2.0 / OIDC.</p>"},{"location":"providers/google/#prerequisites","title":"Prerequisites","text":"<pre><code>pip install \"sreekarnv-fastauth[standard,oauth]\"\n</code></pre> <p>Create a Google OAuth 2.0 client in the Google Cloud Console:</p> <ol> <li>Go to APIs &amp; Services \u2192 Credentials</li> <li>Click Create Credentials \u2192 OAuth client ID</li> <li>Application type: Web application</li> <li>Add an Authorized redirect URI: <code>https://your-domain.com/auth/oauth/callback</code></li> </ol>"},{"location":"providers/google/#setup","title":"Setup","text":"<pre><code>import os\nfrom fastauth.providers.google import GoogleProvider\n\nconfig = FastAuthConfig(\n    providers=[\n        GoogleProvider(\n            client_id=os.environ[\"GOOGLE_CLIENT_ID\"],\n            client_secret=os.environ[\"GOOGLE_CLIENT_SECRET\"],\n        ),\n    ],\n    oauth_adapter=adapter.oauth,\n    oauth_state_store=MemorySessionBackend(),   # or RedisSessionBackend\n    oauth_redirect_url=\"https://your-domain.com/auth/oauth/callback\",\n    ...\n)\n</code></pre>"},{"location":"providers/google/#flow","title":"Flow","text":"<ol> <li>Frontend redirects the user to <code>/auth/oauth/authorize?provider=google</code></li> <li>FastAuth generates a CSRF <code>state</code>, stores it, and redirects to Google's auth page</li> <li>Google redirects back to <code>oauth_redirect_url</code> with <code>code</code> and <code>state</code></li> <li>FastAuth exchanges the code for tokens, fetches the user's Google profile, and either:</li> <li>creates a new local user, or</li> <li>links the Google account to an existing user with the same email</li> <li>FastAuth issues an access + refresh token pair</li> </ol> <pre><code>sequenceDiagram\n    participant U as User\n    participant C as Client App\n    participant FA as FastAuth\n    participant G as Google\n\n    C-&gt;&gt;FA: GET /auth/oauth/authorize?provider=google\n    FA-&gt;&gt;FA: generate state, store in oauth_state_store\n    FA--&gt;&gt;C: 302 Redirect \u2192 Google auth page\n\n    U-&gt;&gt;G: Approves permissions\n    G--&gt;&gt;C: 302 Redirect \u2192 oauth_redirect_url?code=...&amp;state=...\n\n    C-&gt;&gt;FA: GET /auth/oauth/callback?code=...&amp;state=...\n    FA-&gt;&gt;FA: verify state (CSRF check)\n    FA-&gt;&gt;G: exchange code for tokens\n    G--&gt;&gt;FA: {access_token, id_token, ...}\n    FA-&gt;&gt;G: fetch user profile\n    G--&gt;&gt;FA: {email, name, picture, ...}\n    FA-&gt;&gt;FA: find or create local user\n    FA--&gt;&gt;C: {access_token, refresh_token}</code></pre>"},{"location":"providers/google/#requested-scopes","title":"Requested scopes","text":"<p>By default the Google provider requests <code>openid email profile</code>. This gives FastAuth the user's email address and basic profile information.</p>"},{"location":"providers/google/#account-linking","title":"Account linking","text":"<p>If a user with the same email already exists (e.g. they previously signed up with credentials), FastAuth links the Google account to the existing user rather than creating a duplicate.</p>"},{"location":"reference/adapters/","title":"Adapters","text":""},{"location":"reference/adapters/#fastauth.adapters.sqlalchemy.SQLAlchemyAdapter","title":"fastauth.adapters.sqlalchemy.SQLAlchemyAdapter","text":"<p>Factory that creates all FastAuth sub-adapters from a single SQLAlchemy engine.</p> <p>Pass either a connection URL string or a pre-created :class:<code>sqlalchemy.ext.asyncio.AsyncEngine</code>.  All sub-adapters share the same engine and session factory so you don't have to manage multiple connections.</p> <p>Supported databases (via async drivers):</p> Database Driver URL prefix SQLite aiosqlite <code>sqlite+aiosqlite:///...</code> PostgreSQL asyncpg <code>postgresql+asyncpg://...</code> MySQL aiomysql <code>mysql+aiomysql://...</code> Example <pre><code>from fastauth.adapters.sqlalchemy import SQLAlchemyAdapter\n\n# SQLite for local development\nadapter = SQLAlchemyAdapter(engine_url=\"sqlite+aiosqlite:///./auth.db\")\n\nconfig = FastAuthConfig(\n    secret=\"...\",\n    providers=[...],\n    adapter=adapter.user,\n    token_adapter=adapter.token,\n    oauth_adapter=adapter.oauth,\n)\n\n# Create tables on startup\n@asynccontextmanager\nasync def lifespan(app):\n    await adapter.create_tables()\n    yield\n</code></pre>"},{"location":"reference/adapters/#fastauth.adapters.sqlalchemy.SQLAlchemyAdapter.user","title":"user  <code>property</code>","text":"<pre><code>user: SQLAlchemyUserAdapter\n</code></pre> <p>Return a :class:<code>~fastauth.adapters.sqlalchemy.user.SQLAlchemyUserAdapter</code>.</p>"},{"location":"reference/adapters/#fastauth.adapters.sqlalchemy.SQLAlchemyAdapter.token","title":"token  <code>property</code>","text":"<pre><code>token: SQLAlchemyTokenAdapter\n</code></pre> <p>Return a :class:<code>~fastauth.adapters.sqlalchemy.token.SQLAlchemyTokenAdapter</code>.</p>"},{"location":"reference/adapters/#fastauth.adapters.sqlalchemy.SQLAlchemyAdapter.session","title":"session  <code>property</code>","text":"<pre><code>session: SQLAlchemySessionAdapter\n</code></pre> <p>Return a :class:        <code>~fastauth.adapters.sqlalchemy.session.SQLAlchemySessionAdapter</code>.</p>"},{"location":"reference/adapters/#fastauth.adapters.sqlalchemy.SQLAlchemyAdapter.role","title":"role  <code>property</code>","text":"<pre><code>role: SQLAlchemyRoleAdapter\n</code></pre> <p>Return a :class:<code>~fastauth.adapters.sqlalchemy.rbac.SQLAlchemyRoleAdapter</code>.</p>"},{"location":"reference/adapters/#fastauth.adapters.sqlalchemy.SQLAlchemyAdapter.oauth","title":"oauth  <code>property</code>","text":"<pre><code>oauth: SQLAlchemyOAuthAccountAdapter\n</code></pre> <p>Returns a :class:         <code>~fastauth.adapters.sqlalchemy.oauth.SQLAlchemyOAuthAccountAdapter</code>.</p>"},{"location":"reference/adapters/#fastauth.adapters.sqlalchemy.SQLAlchemyAdapter.__init__","title":"__init__","text":"<pre><code>__init__(\n    engine_url: str | None = None,\n    engine: AsyncEngine | None = None,\n) -&gt; None\n</code></pre> <p>Initialize the adapter with a connection URL or an existing engine.</p> <p>Parameters:</p> Name Type Description Default <code>engine_url</code> <code>str | None</code> <p>SQLAlchemy async connection string.</p> <code>None</code> <code>engine</code> <code>AsyncEngine | None</code> <p>A pre-created :class:<code>~sqlalchemy.ext.asyncio.AsyncEngine</code>.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither engine_url nor engine is provided.</p>"},{"location":"reference/adapters/#fastauth.adapters.sqlalchemy.SQLAlchemyAdapter.create_tables","title":"create_tables  <code>async</code>","text":"<pre><code>create_tables() -&gt; None\n</code></pre> <p>Create all FastAuth database tables if they do not already exist.</p> <p>Safe to call on every startup \u2014 uses <code>CREATE TABLE IF NOT EXISTS</code> semantics via SQLAlchemy's <code>create_all</code>.</p>"},{"location":"reference/adapters/#fastauth.adapters.sqlalchemy.SQLAlchemyAdapter.drop_tables","title":"drop_tables  <code>async</code>","text":"<pre><code>drop_tables() -&gt; None\n</code></pre> <p>Drop all FastAuth database tables.</p> <p>Intended for testing and local teardown only.  Do not call in production \u2014 all user data will be permanently deleted.</p>"},{"location":"reference/adapters/#fastauth.adapters.memory.MemoryUserAdapter","title":"fastauth.adapters.memory.MemoryUserAdapter","text":"<p>               Bases: <code>UserAdapter</code></p> <p>In-memory user adapter for testing.</p>"},{"location":"reference/adapters/#fastauth.adapters.memory.MemoryTokenAdapter","title":"fastauth.adapters.memory.MemoryTokenAdapter","text":"<p>In-memory one-time token adapter for testing.</p>"},{"location":"reference/adapters/#fastauth.adapters.memory.MemorySessionAdapter","title":"fastauth.adapters.memory.MemorySessionAdapter","text":"<p>In-memory session adapter for testing.</p>"},{"location":"reference/adapters/#fastauth.adapters.memory.MemoryRoleAdapter","title":"fastauth.adapters.memory.MemoryRoleAdapter","text":"<p>In-memory RBAC adapter for testing.</p>"},{"location":"reference/adapters/#fastauth.adapters.memory.MemoryOAuthAccountAdapter","title":"fastauth.adapters.memory.MemoryOAuthAccountAdapter","text":"<p>In-memory OAuth account adapter for testing.</p>"},{"location":"reference/config/","title":"Configuration","text":""},{"location":"reference/config/#fastauth.config.FastAuthConfig","title":"fastauth.config.FastAuthConfig  <code>dataclass</code>","text":"<p>Top-level configuration for a :class:<code>~fastauth.app.FastAuth</code> instance.</p> <p>The three required fields are secret, providers, and adapter. All other fields have sensible defaults.</p> <p>Attributes:</p> Name Type Description <code>secret</code> <code>str</code> <p>HMAC shared secret used to sign tokens when <code>jwt.algorithm</code> is <code>\"HS256\"</code>. Generate a secure value with <code>fastauth generate-secret</code>.</p> <code>providers</code> <code>list[Any]</code> <p>One or more provider instances \u2014 e.g. <code>CredentialsProvider()</code>, <code>GoogleProvider(...)</code>, <code>GitHubProvider(...)</code>.</p> <code>adapter</code> <code>UserAdapter</code> <p>A :class:<code>~fastauth.core.protocols.UserAdapter</code> implementation that reads and writes user records in your database.</p> <code>jwt</code> <code>JWTConfig</code> <p>JWT signing and TTL configuration; defaults to HS256 with 15-minute access tokens.</p> <code>session_strategy</code> <code>Literal['jwt', 'database']</code> <p><code>\"jwt\"</code> for stateless JWT sessions (default) or <code>\"database\"</code> for server-side sessions stored in session_backend.</p> <code>route_prefix</code> <code>str</code> <p>URL prefix for all FastAuth endpoints (default: <code>\"/auth\"</code>).</p> <code>session_backend</code> <code>SessionBackend | None</code> <p>Required when session_strategy is <code>\"database\"</code>. Provide a :class:<code>~fastauth.core.protocols.SessionBackend</code> such as :class:<code>~fastauth.session_backends.redis.RedisSessionBackend</code>.</p> <code>email_transport</code> <code>EmailTransport | None</code> <p>Transport used to deliver verification and password-reset emails. Omit to disable email flows entirely.</p> <code>hooks</code> <code>EventHooks | None</code> <p>An :class:<code>~fastauth.core.protocols.EventHooks</code> subclass for lifecycle callbacks (<code>on_signup</code>, <code>modify_jwt</code>, etc.).</p> <code>oauth_adapter</code> <code>OAuthAccountAdapter | None</code> <p>Adapter for persisting linked OAuth accounts.</p> <code>oauth_state_store</code> <code>SessionBackend | None</code> <p>Session backend used to store OAuth CSRF state.</p> <code>oauth_redirect_url</code> <code>str | None</code> <p>Full callback URL registered with OAuth providers (e.g. <code>\"https://example.com/auth/oauth/callback\"</code>).</p> <code>token_adapter</code> <code>TokenAdapter | None</code> <p>Adapter for persisting one-time verification/reset tokens.</p> <code>base_url</code> <code>str</code> <p>Public base URL of your application; used when building email verification / password-reset links.</p> <code>cors_origins</code> <code>list[str] | None</code> <p>Allowed CORS origins. <code>None</code> disables CORS middleware.</p> <code>roles</code> <code>list[dict[str, Any]] | None</code> <p>Seed role definitions applied on startup.</p> <code>default_role</code> <code>str | None</code> <p>Role automatically assigned to every new user.</p> <code>debug</code> <code>bool</code> <p>Relaxes cookie security (<code>Secure=False</code>) and enables verbose error output. Never enable in production.</p> <code>token_delivery</code> <code>Literal['json', 'cookie']</code> <p><code>\"json\"</code> returns tokens in the response body; <code>\"cookie\"</code> sets them as HttpOnly cookies.</p> <code>cookie_name_access</code> <code>str</code> <p>Name of the access-token cookie (default: <code>\"access_token\"</code>).</p> <code>cookie_name_refresh</code> <code>str</code> <p>Name of the refresh-token cookie (default: <code>\"refresh_token\"</code>).</p> <code>cookie_secure</code> <code>bool | None</code> <p>Explicit <code>Secure</code> flag override; defaults to <code>not debug</code>.</p> <code>cookie_httponly</code> <code>bool</code> <p><code>HttpOnly</code> cookie flag (default: <code>True</code>).</p> <code>cookie_samesite</code> <code>Literal['lax', 'strict', 'none']</code> <p><code>SameSite</code> policy \u2014 <code>\"lax\"</code>, <code>\"strict\"</code>, or <code>\"none\"</code> (default: <code>\"lax\"</code>).</p> <code>cookie_domain</code> <code>str | None</code> <p>Optional domain scope for cookies.</p>"},{"location":"reference/config/#fastauth.config.JWTConfig","title":"fastauth.config.JWTConfig  <code>dataclass</code>","text":"<p>JWT signing and validation settings.</p> <p>All TTL values are in seconds.</p> <p>Attributes:</p> Name Type Description <code>algorithm</code> <code>str</code> <p>Signing algorithm \u2014 <code>\"HS256\"</code> for HMAC shared-secret, <code>\"RS256\"</code> / <code>\"RS512\"</code> for RSA key-pair signing.</p> <code>access_token_ttl</code> <code>int</code> <p>Lifetime of access tokens (default: 900 = 15 minutes).</p> <code>refresh_token_ttl</code> <code>int</code> <p>Lifetime of refresh tokens (default: 2 592 000 = 30 days).</p> <code>issuer</code> <code>str | None</code> <p>Optional <code>iss</code> claim embedded in every token.</p> <code>audience</code> <code>list[str] | None</code> <p>Optional <code>aud</code> claim; validated on every decode.</p> <code>jwks_enabled</code> <code>bool</code> <p>When <code>True</code>, expose a <code>/.well-known/jwks.json</code> endpoint and rotate RSA keys automatically.</p> <code>key_rotation_interval</code> <code>int | None</code> <p>Seconds between automatic RSA key rotations when <code>jwks_enabled=True</code>. <code>None</code> disables auto-rotation.</p> <code>private_key</code> <code>str | None</code> <p>PEM-encoded RSA private key (required for RS256/RS512).</p> <code>public_key</code> <code>str | None</code> <p>PEM-encoded RSA public key (required for RS256/RS512).</p>"},{"location":"reference/deps/","title":"Dependencies","text":""},{"location":"reference/deps/#fastauth.api.deps.require_auth","title":"fastauth.api.deps.require_auth  <code>async</code>","text":"<pre><code>require_auth(user=Depends(get_current_user)) -&gt; UserData\n</code></pre> <p>FastAPI dependency that enforces authentication.</p> <p>Reads the access token from the <code>Authorization: Bearer</code> header or the configured access-token cookie (<code>FastAuthConfig.cookie_name_access</code>). Returns the current user record on success.</p> Example <pre><code>from fastapi import Depends\nfrom fastauth.api.deps import require_auth\nfrom fastauth.types import UserData\n\n@app.get(\"/profile\")\nasync def profile(user: UserData = Depends(require_auth)):\n    return {\"email\": user[\"email\"]}\n</code></pre> <p>Raises:</p> Type Description <code>HTTPException(401)</code> <p>If no valid access token is present or the token is expired / malformed.</p>"},{"location":"reference/deps/#fastauth.api.deps.require_role","title":"fastauth.api.deps.require_role","text":"<pre><code>require_role(role_name: str) -&gt; Any\n</code></pre> <p>Return a FastAPI dependency that enforces a specific RBAC role.</p> <p>The requesting user must be authenticated and have role_name assigned. RBAC must be configured \u2014 i.e. <code>role_adapter</code> must be set on the :class:<code>~fastauth.app.FastAuth</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>role_name</code> <code>str</code> <p>The role the user must hold (e.g. <code>\"admin\"</code>).</p> required Example <pre><code>from fastauth.api.deps import require_role\n\n@app.get(\"/admin\")\nasync def admin_area(user: UserData = Depends(require_role(\"admin\"))):\n    return {\"message\": \"Welcome, admin\"}\n</code></pre> <p>Raises:</p> Type Description <code>HTTPException(401)</code> <p>If the user is not authenticated.</p> <code>HTTPException(403)</code> <p>If the user does not hold role_name.</p> <code>HTTPException(500)</code> <p>If RBAC is not configured on the FastAuth instance.</p>"},{"location":"reference/deps/#fastauth.api.deps.require_permission","title":"fastauth.api.deps.require_permission","text":"<pre><code>require_permission(permission: str) -&gt; Any\n</code></pre> <p>Return a FastAPI dependency that enforces a specific RBAC permission.</p> <p>Checks that the authenticated user holds at least one role that includes permission. RBAC must be configured on the :class:<code>~fastauth.app.FastAuth</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>permission</code> <code>str</code> <p>The permission string to check (e.g. <code>\"reports:read\"</code>).</p> required Example <pre><code>from fastauth.api.deps import require_permission\n\n@app.get(\"/reports\")\nasync def reports(user: UserData = Depends(require_permission(\"reports:read\"))):\n    return {\"message\": \"Here are your reports\"}\n</code></pre> <p>Raises:</p> Type Description <code>HTTPException(401)</code> <p>If the user is not authenticated.</p> <code>HTTPException(403)</code> <p>If the user lacks permission.</p> <code>HTTPException(500)</code> <p>If RBAC is not configured on the FastAuth instance.</p>"},{"location":"reference/email-transports/","title":"Email Transports","text":""},{"location":"reference/email-transports/#fastauth.email_transports.console.ConsoleTransport","title":"fastauth.email_transports.console.ConsoleTransport","text":"<p>Email transport that prints to stdout (development only).</p>"},{"location":"reference/email-transports/#fastauth.email_transports.smtp.SMTPTransport","title":"fastauth.email_transports.smtp.SMTPTransport","text":"<p>SMTP email transport using aiosmtplib.</p>"},{"location":"reference/email-transports/#fastauth.email_transports.webhook.WebhookTransport","title":"fastauth.email_transports.webhook.WebhookTransport","text":"<p>HTTP webhook email transport (POST JSON payload).</p>"},{"location":"reference/exceptions/","title":"Exceptions","text":""},{"location":"reference/exceptions/#fastauth.exceptions.FastAuthError","title":"fastauth.exceptions.FastAuthError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all FastAuth errors.</p>"},{"location":"reference/exceptions/#fastauth.exceptions.ConfigError","title":"fastauth.exceptions.ConfigError","text":"<p>               Bases: <code>FastAuthError</code></p> <p>Raised when the :class:<code>~fastauth.config.FastAuthConfig</code> is invalid.</p> <p>Common causes: missing <code>secret</code>, no providers configured, or a <code>session_strategy=\"database\"</code> without a <code>session_backend</code>.</p>"},{"location":"reference/exceptions/#fastauth.exceptions.MissingDependencyError","title":"fastauth.exceptions.MissingDependencyError","text":"<p>               Bases: <code>FastAuthError</code></p> <p>Raised when an optional dependency is not installed.</p> <p>FastAuth uses optional extras (<code>jwt</code>, <code>oauth</code>, <code>sqlalchemy</code>, etc.). This error tells you exactly which package to install and which extra to use.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>The missing Python package name.</p> required <code>extra</code> <code>str</code> <p>The FastAuth extra that includes the package.</p> required"},{"location":"reference/exceptions/#fastauth.exceptions.AuthenticationError","title":"fastauth.exceptions.AuthenticationError","text":"<p>               Bases: <code>FastAuthError</code></p> <p>Raised when authentication fails.</p> <p>Covers bad credentials, expired tokens, revoked sessions, and similar scenarios where the identity of the requester cannot be confirmed.</p>"},{"location":"reference/exceptions/#fastauth.exceptions.UserAlreadyExistsError","title":"fastauth.exceptions.UserAlreadyExistsError","text":"<p>               Bases: <code>FastAuthError</code></p> <p>Raised when attempting to register an email address that is already taken.</p>"},{"location":"reference/exceptions/#fastauth.exceptions.UserNotFoundError","title":"fastauth.exceptions.UserNotFoundError","text":"<p>               Bases: <code>FastAuthError</code></p> <p>Raised when a user lookup returns no result.</p>"},{"location":"reference/exceptions/#fastauth.exceptions.InvalidTokenError","title":"fastauth.exceptions.InvalidTokenError","text":"<p>               Bases: <code>FastAuthError</code></p> <p>Raised when a token is invalid, expired, or has been revoked.</p>"},{"location":"reference/exceptions/#fastauth.exceptions.ProviderError","title":"fastauth.exceptions.ProviderError","text":"<p>               Bases: <code>FastAuthError</code></p> <p>Raised when an auth provider returns an error.</p> <p>Typically wraps OAuth provider failures (bad <code>code</code>, revoked tokens, etc.).</p>"},{"location":"reference/fastauth/","title":"FastAuth","text":""},{"location":"reference/fastauth/#fastauth.app.FastAuth","title":"fastauth.app.FastAuth","text":"<p>Central FastAuth instance wires configuration, providers, and adapters together.</p> <p>Pass a :class:<code>~fastauth.config.FastAuthConfig</code> to the constructor, then call :meth:<code>mount</code> to attach all authentication routes to a FastAPI application.</p> Example <pre><code>from fastauth import FastAuth, FastAuthConfig\nfrom fastauth.providers.credentials import CredentialsProvider\nfrom fastauth.adapters.sqlalchemy import SQLAlchemyAdapter\n\nadapter = SQLAlchemyAdapter(engine_url=\"sqlite+aiosqlite:///./auth.db\")\n\nconfig = FastAuthConfig(\n    secret=\"change-me-in-production\",\n    providers=[CredentialsProvider()],\n    adapter=adapter.user,\n    token_adapter=adapter.token,\n)\n\nauth = FastAuth(config)\n</code></pre>"},{"location":"reference/fastauth/#fastauth.app.FastAuth.__init__","title":"__init__","text":"<pre><code>__init__(config: FastAuthConfig) -&gt; None\n</code></pre> <p>Initialize FastAuth with the given configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>FastAuthConfig</code> <p>A fully-populated :class:<code>~fastauth.config.FastAuthConfig</code>.</p> required"},{"location":"reference/fastauth/#fastauth.app.FastAuth.mount","title":"mount","text":"<pre><code>mount(app: object) -&gt; None\n</code></pre> <p>Mount all FastAuth routes onto a FastAPI application.</p> <p>Attaches the authentication router at <code>config.route_prefix</code> (default <code>/auth</code>). Also mounts the <code>/.well-known/jwks.json</code> endpoint when a JWKS manager has been initialized.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>object</code> <p>A :class:<code>fastapi.FastAPI</code> instance.</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>If app is not a :class:<code>fastapi.FastAPI</code> instance.</p> <code>MissingDependencyError</code> <p>If the <code>fastapi</code> extra is not installed.</p>"},{"location":"reference/fastauth/#fastauth.app.FastAuth.initialize_jwks","title":"initialize_jwks  <code>async</code>","text":"<pre><code>initialize_jwks() -&gt; None\n</code></pre> <p>Initialize the JWKS manager for RSA-based JWT signing.</p> <p>Must be called inside the application lifespan startup handler when using <code>RS256</code> / <code>RS512</code> algorithms with <code>jwks_enabled=True</code>.</p> Example <pre><code>from contextlib import asynccontextmanager\nfrom fastapi import FastAPI\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    await auth.initialize_jwks()\n    yield\n\napp = FastAPI(lifespan=lifespan)\nauth.mount(app)\n</code></pre>"},{"location":"reference/protocols/","title":"Protocols","text":""},{"location":"reference/protocols/#fastauth.core.protocols.UserAdapter","title":"fastauth.core.protocols.UserAdapter","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for reading and writing user records.</p> <p>Implement this interface to integrate FastAuth with any data store. The :class:<code>~fastauth.adapters.sqlalchemy.SQLAlchemyAdapter</code> provides a ready-made implementation; for testing use :class:<code>~fastauth.adapters.memory.MemoryUserAdapter</code>.</p>"},{"location":"reference/protocols/#fastauth.core.protocols.SessionAdapter","title":"fastauth.core.protocols.SessionAdapter","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for persisting server-side sessions (<code>session_strategy=\"database\"</code>).</p>"},{"location":"reference/protocols/#fastauth.core.protocols.TokenAdapter","title":"fastauth.core.protocols.TokenAdapter","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for persisting one-time tokens (email verification, password reset).</p>"},{"location":"reference/protocols/#fastauth.core.protocols.OAuthAccountAdapter","title":"fastauth.core.protocols.OAuthAccountAdapter","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for persisting linked OAuth provider accounts.</p>"},{"location":"reference/protocols/#fastauth.core.protocols.RoleAdapter","title":"fastauth.core.protocols.RoleAdapter","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for managing roles and permissions (RBAC).</p>"},{"location":"reference/protocols/#fastauth.core.protocols.SessionBackend","title":"fastauth.core.protocols.SessionBackend","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for key-value session storage (OAuth state, server sessions).</p>"},{"location":"reference/protocols/#fastauth.core.protocols.EmailTransport","title":"fastauth.core.protocols.EmailTransport","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for sending transactional emails.</p>"},{"location":"reference/protocols/#fastauth.core.protocols.EventHooks","title":"fastauth.core.protocols.EventHooks","text":"<p>Base class for FastAuth lifecycle hooks.</p> <p>Subclass and override whichever events you care about, then pass an instance as <code>FastAuthConfig.hooks</code>.</p> Example <pre><code>from fastauth.core.protocols import EventHooks\nfrom fastauth.types import UserData\n\nclass MyHooks(EventHooks):\n    async def on_signup(self, user: UserData) -&gt; None:\n        await send_welcome_email(user[\"email\"])\n\n    async def modify_jwt(self, token: dict, user: UserData) -&gt; dict:\n        token[\"plan\"] = await get_user_plan(user[\"id\"])\n        return token\n\nconfig = FastAuthConfig(..., hooks=MyHooks())\n</code></pre>"},{"location":"reference/protocols/#fastauth.core.protocols.EventHooks.on_signup","title":"on_signup  <code>async</code>","text":"<pre><code>on_signup(user: UserData) -&gt; None\n</code></pre> <p>Called after a new user is created.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>UserData</code> <p>The newly created user record.</p> required"},{"location":"reference/protocols/#fastauth.core.protocols.EventHooks.on_signin","title":"on_signin  <code>async</code>","text":"<pre><code>on_signin(user: UserData, provider: str) -&gt; None\n</code></pre> <p>Called after a successful sign-in.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>UserData</code> <p>The authenticated user.</p> required <code>provider</code> <code>str</code> <p>Provider ID (e.g. <code>\"credentials\"</code>, <code>\"google\"</code>).</p> required"},{"location":"reference/protocols/#fastauth.core.protocols.EventHooks.on_signout","title":"on_signout  <code>async</code>","text":"<pre><code>on_signout(user: UserData) -&gt; None\n</code></pre> <p>Called after a user signs out.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>UserData</code> <p>The user who signed out.</p> required"},{"location":"reference/protocols/#fastauth.core.protocols.EventHooks.on_token_refresh","title":"on_token_refresh  <code>async</code>","text":"<pre><code>on_token_refresh(user: UserData) -&gt; None\n</code></pre> <p>Called after a token pair is refreshed.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>UserData</code> <p>The user whose tokens were refreshed.</p> required"},{"location":"reference/protocols/#fastauth.core.protocols.EventHooks.on_email_verify","title":"on_email_verify  <code>async</code>","text":"<pre><code>on_email_verify(user: UserData) -&gt; None\n</code></pre> <p>Called after a user successfully verifies their email address.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>UserData</code> <p>The user whose email was verified.</p> required"},{"location":"reference/protocols/#fastauth.core.protocols.EventHooks.on_password_reset","title":"on_password_reset  <code>async</code>","text":"<pre><code>on_password_reset(user: UserData) -&gt; None\n</code></pre> <p>Called after a user successfully resets their password.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>UserData</code> <p>The user who reset their password.</p> required"},{"location":"reference/protocols/#fastauth.core.protocols.EventHooks.on_oauth_link","title":"on_oauth_link  <code>async</code>","text":"<pre><code>on_oauth_link(user: UserData, provider: str) -&gt; None\n</code></pre> <p>Called after an OAuth account is linked to an existing user.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>UserData</code> <p>The user who linked the account.</p> required <code>provider</code> <code>str</code> <p>The OAuth provider ID (e.g. <code>\"google\"</code>).</p> required"},{"location":"reference/protocols/#fastauth.core.protocols.EventHooks.allow_signin","title":"allow_signin  <code>async</code>","text":"<pre><code>allow_signin(user: UserData, provider: str) -&gt; bool\n</code></pre> <p>Gate hook \u2014 return <code>False</code> to block sign-in for a specific user.</p> <p>Runs before the session or token is issued. Returning <code>False</code> causes FastAuth to respond with HTTP 403.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>UserData</code> <p>The user attempting to sign in.</p> required <code>provider</code> <code>str</code> <p>The provider being used.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> to allow sign-in, <code>False</code> to deny it.</p>"},{"location":"reference/protocols/#fastauth.core.protocols.EventHooks.modify_session","title":"modify_session  <code>async</code>","text":"<pre><code>modify_session(\n    session: dict[str, Any], user: UserData\n) -&gt; dict[str, Any]\n</code></pre> <p>Mutate the database session payload before it is persisted.</p> <p>Only called when <code>session_strategy=\"database\"</code>.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>dict[str, Any]</code> <p>The default session dict.</p> required <code>user</code> <code>UserData</code> <p>The authenticated user.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The (possibly modified) session dict.</p>"},{"location":"reference/protocols/#fastauth.core.protocols.EventHooks.modify_jwt","title":"modify_jwt  <code>async</code>","text":"<pre><code>modify_jwt(\n    token: dict[str, Any], user: UserData\n) -&gt; dict[str, Any]\n</code></pre> <p>Mutate the JWT payload before it is signed.</p> <p>Use this to embed extra claims such as roles, permissions, or subscription tiers directly in the token so downstream services don't need a database lookup.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>dict[str, Any]</code> <p>The default token payload (includes <code>sub</code>, <code>type</code>, <code>exp</code>).</p> required <code>user</code> <code>UserData</code> <p>The authenticated user.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The (possibly modified) token payload.</p>"},{"location":"reference/providers/","title":"Providers","text":""},{"location":"reference/providers/#fastauth.providers.credentials.CredentialsProvider","title":"fastauth.providers.credentials.CredentialsProvider","text":"<p>Email/password provider using Argon2/bcrypt hashing.</p>"},{"location":"reference/providers/#fastauth.providers.google.GoogleProvider","title":"fastauth.providers.google.GoogleProvider","text":"<p>Google OAuth 2.0 / OIDC provider.</p>"},{"location":"reference/providers/#fastauth.providers.github.GitHubProvider","title":"fastauth.providers.github.GitHubProvider","text":"<p>GitHub OAuth 2.0 provider.</p>"},{"location":"reference/session-backends/","title":"Session Backends","text":""},{"location":"reference/session-backends/#fastauth.session_backends.memory.MemorySessionBackend","title":"fastauth.session_backends.memory.MemorySessionBackend","text":"<p>In-memory key-value session backend for testing.</p>"},{"location":"reference/session-backends/#fastauth.session_backends.redis.RedisSessionBackend","title":"fastauth.session_backends.redis.RedisSessionBackend","text":"<p>Redis-backed session backend for production use.</p>"},{"location":"reference/session-backends/#fastauth.session_backends.database.DatabaseSessionBackend","title":"fastauth.session_backends.database.DatabaseSessionBackend","text":"<p>Database-backed session backend via a SessionAdapter.</p>"},{"location":"reference/types/","title":"Types","text":""},{"location":"reference/types/#fastauth.types.UserData","title":"fastauth.types.UserData","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/types/#fastauth.types.SessionData","title":"fastauth.types.SessionData","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/types/#fastauth.types.TokenData","title":"fastauth.types.TokenData","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/types/#fastauth.types.OAuthAccountData","title":"fastauth.types.OAuthAccountData","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/types/#fastauth.types.RoleData","title":"fastauth.types.RoleData","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/types/#fastauth.types.TokenPair","title":"fastauth.types.TokenPair","text":"<p>               Bases: <code>TypedDict</code></p>"}]}